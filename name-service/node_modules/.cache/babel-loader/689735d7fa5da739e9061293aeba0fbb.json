{"ast":null,"code":"import has from \"lodash-es/has\";\nimport isSchema from './util/isSchema';\n\nvar Condition = /*#__PURE__*/function () {\n  function Condition(refs, options) {\n    this.refs = refs;\n\n    if (typeof options === 'function') {\n      this.fn = options;\n      return;\n    }\n\n    if (!has(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    var is = options.is,\n        then = options.then,\n        otherwise = options.otherwise;\n    var check = typeof is === 'function' ? is : function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      return values.every(function (value) {\n        return value === is;\n      });\n    };\n\n    this.fn = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var options = args.pop();\n      var schema = args.pop();\n      var branch = check.apply(void 0, args) ? then : otherwise;\n      if (!branch) return undefined;\n      if (typeof branch === 'function') return branch(schema);\n      return schema.concat(branch.resolve(options));\n    };\n  }\n\n  var _proto = Condition.prototype;\n\n  _proto.resolve = function resolve(base, options) {\n    var values = this.refs.map(function (ref) {\n      return ref.getValue(options);\n    });\n    var schema = this.fn.apply(base, values.concat(base, options));\n    if (schema === undefined || schema === base) return base;\n    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');\n    return schema.resolve(options);\n  };\n\n  return Condition;\n}();\n\nexport default Condition;","map":{"version":3,"sources":["/home/abefernan/cosmwasm/dApps/node_modules/yup/es/Condition.js"],"names":["has","isSchema","Condition","refs","options","fn","TypeError","then","otherwise","is","check","_len","arguments","length","values","Array","_key","every","value","_len2","args","_key2","pop","schema","branch","apply","undefined","concat","resolve","_proto","prototype","base","map","ref","getValue"],"mappings":"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","sourcesContent":["import has from \"lodash-es/has\";\nimport isSchema from './util/isSchema';\n\nvar Condition = /*#__PURE__*/function () {\n  function Condition(refs, options) {\n    this.refs = refs;\n\n    if (typeof options === 'function') {\n      this.fn = options;\n      return;\n    }\n\n    if (!has(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n    if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    var is = options.is,\n        then = options.then,\n        otherwise = options.otherwise;\n    var check = typeof is === 'function' ? is : function () {\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      return values.every(function (value) {\n        return value === is;\n      });\n    };\n\n    this.fn = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var options = args.pop();\n      var schema = args.pop();\n      var branch = check.apply(void 0, args) ? then : otherwise;\n      if (!branch) return undefined;\n      if (typeof branch === 'function') return branch(schema);\n      return schema.concat(branch.resolve(options));\n    };\n  }\n\n  var _proto = Condition.prototype;\n\n  _proto.resolve = function resolve(base, options) {\n    var values = this.refs.map(function (ref) {\n      return ref.getValue(options);\n    });\n    var schema = this.fn.apply(base, values.concat(base, options));\n    if (schema === undefined || schema === base) return base;\n    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');\n    return schema.resolve(options);\n  };\n\n  return Condition;\n}();\n\nexport default Condition;"]},"metadata":{},"sourceType":"module"}