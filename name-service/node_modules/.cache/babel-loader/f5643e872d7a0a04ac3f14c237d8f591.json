{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBech32Pubkey = exports.decodeBech32Pubkey = exports.encodeSecp256k1Pubkey = void 0;\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nconst types_1 = require(\"./types\");\n\nfunction encodeSecp256k1Pubkey(pubkey) {\n  if (pubkey.length !== 33 || pubkey[0] !== 0x02 && pubkey[0] !== 0x03) {\n    throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n  }\n\n  return {\n    type: types_1.pubkeyType.secp256k1,\n    value: encoding_1.toBase64(pubkey)\n  };\n}\n\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey; // As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\n\nconst pubkeyAminoPrefixSecp256k1 = encoding_1.fromHex(\"eb5ae98721\");\nconst pubkeyAminoPrefixEd25519 = encoding_1.fromHex(\"1624de6420\");\nconst pubkeyAminoPrefixSr25519 = encoding_1.fromHex(\"0dfb1005\");\nconst pubkeyAminoPrefixLength = pubkeyAminoPrefixSecp256k1.length;\n\nfunction decodeBech32Pubkey(bechEncoded) {\n  const {\n    data\n  } = encoding_1.Bech32.decode(bechEncoded);\n  const aminoPrefix = data.slice(0, pubkeyAminoPrefixLength);\n  const rest = data.slice(pubkeyAminoPrefixLength);\n\n  if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSecp256k1)) {\n    if (rest.length !== 33) {\n      throw new Error(\"Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).\");\n    }\n\n    return {\n      type: types_1.pubkeyType.secp256k1,\n      value: encoding_1.toBase64(rest)\n    };\n  } else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixEd25519)) {\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).\");\n    }\n\n    return {\n      type: types_1.pubkeyType.ed25519,\n      value: encoding_1.toBase64(rest)\n    };\n  } else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSr25519)) {\n    if (rest.length !== 32) {\n      throw new Error(\"Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).\");\n    }\n\n    return {\n      type: types_1.pubkeyType.sr25519,\n      value: encoding_1.toBase64(rest)\n    };\n  } else {\n    throw new Error(\"Unsupported Pubkey type. Amino prefix: \" + encoding_1.toHex(aminoPrefix));\n  }\n}\n\nexports.decodeBech32Pubkey = decodeBech32Pubkey;\n\nfunction encodeBech32Pubkey(pubkey, prefix) {\n  let aminoPrefix;\n\n  switch (pubkey.type) {\n    // Note: please don't add cases here without writing additional unit tests\n    case types_1.pubkeyType.secp256k1:\n      aminoPrefix = pubkeyAminoPrefixSecp256k1;\n      break;\n\n    default:\n      throw new Error(\"Unsupported pubkey type\");\n  }\n\n  const data = new Uint8Array([...aminoPrefix, ...encoding_1.fromBase64(pubkey.value)]);\n  return encoding_1.Bech32.encode(prefix, data);\n}\n\nexports.encodeBech32Pubkey = encodeBech32Pubkey;","map":{"version":3,"sources":["../src/pubkey.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeBech32Pubkey = exports.decodeBech32Pubkey = exports.encodeSecp256k1Pubkey = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\nconst types_1 = require(\"./types\");\nfunction encodeSecp256k1Pubkey(pubkey) {\n    if (pubkey.length !== 33 || (pubkey[0] !== 0x02 && pubkey[0] !== 0x03)) {\n        throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n    }\n    return {\n        type: types_1.pubkeyType.secp256k1,\n        value: encoding_1.toBase64(pubkey),\n    };\n}\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;\n// As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\nconst pubkeyAminoPrefixSecp256k1 = encoding_1.fromHex(\"eb5ae98721\");\nconst pubkeyAminoPrefixEd25519 = encoding_1.fromHex(\"1624de6420\");\nconst pubkeyAminoPrefixSr25519 = encoding_1.fromHex(\"0dfb1005\");\nconst pubkeyAminoPrefixLength = pubkeyAminoPrefixSecp256k1.length;\nfunction decodeBech32Pubkey(bechEncoded) {\n    const { data } = encoding_1.Bech32.decode(bechEncoded);\n    const aminoPrefix = data.slice(0, pubkeyAminoPrefixLength);\n    const rest = data.slice(pubkeyAminoPrefixLength);\n    if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSecp256k1)) {\n        if (rest.length !== 33) {\n            throw new Error(\"Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).\");\n        }\n        return {\n            type: types_1.pubkeyType.secp256k1,\n            value: encoding_1.toBase64(rest),\n        };\n    }\n    else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixEd25519)) {\n        if (rest.length !== 32) {\n            throw new Error(\"Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).\");\n        }\n        return {\n            type: types_1.pubkeyType.ed25519,\n            value: encoding_1.toBase64(rest),\n        };\n    }\n    else if (fast_deep_equal_1.default(aminoPrefix, pubkeyAminoPrefixSr25519)) {\n        if (rest.length !== 32) {\n            throw new Error(\"Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).\");\n        }\n        return {\n            type: types_1.pubkeyType.sr25519,\n            value: encoding_1.toBase64(rest),\n        };\n    }\n    else {\n        throw new Error(\"Unsupported Pubkey type. Amino prefix: \" + encoding_1.toHex(aminoPrefix));\n    }\n}\nexports.decodeBech32Pubkey = decodeBech32Pubkey;\nfunction encodeBech32Pubkey(pubkey, prefix) {\n    let aminoPrefix;\n    switch (pubkey.type) {\n        // Note: please don't add cases here without writing additional unit tests\n        case types_1.pubkeyType.secp256k1:\n            aminoPrefix = pubkeyAminoPrefixSecp256k1;\n            break;\n        default:\n            throw new Error(\"Unsupported pubkey type\");\n    }\n    const data = new Uint8Array([...aminoPrefix, ...encoding_1.fromBase64(pubkey.value)]);\n    return encoding_1.Bech32.encode(prefix, data);\n}\nexports.encodeBech32Pubkey = encodeBech32Pubkey;\n//# sourceMappingURL=pubkey.js.map"]},"metadata":{},"sourceType":"script"}