{"ast":null,"code":"/*! MIT License © Sindre Sorhus */\nconst globals = {};\n\nconst getGlobal = property => {\n  /* istanbul ignore next */\n  if (typeof self !== 'undefined' && self && property in self) {\n    return self;\n  }\n  /* istanbul ignore next */\n\n\n  if (typeof window !== 'undefined' && window && property in window) {\n    return window;\n  }\n\n  if (typeof global !== 'undefined' && global && property in global) {\n    return global;\n  }\n  /* istanbul ignore next */\n\n\n  if (typeof globalThis !== 'undefined' && globalThis) {\n    return globalThis;\n  }\n};\n\nconst globalProperties = ['Headers', 'Request', 'Response', 'ReadableStream', 'fetch', 'AbortController', 'FormData'];\n\nfor (const property of globalProperties) {\n  Object.defineProperty(globals, property, {\n    get() {\n      const globalObject = getGlobal(property);\n      const value = globalObject && globalObject[property];\n      return typeof value === 'function' ? value.bind(globalObject) : value;\n    }\n\n  });\n}\n\nconst isObject = value => value !== null && typeof value === 'object';\n\nconst supportsAbortController = typeof globals.AbortController === 'function';\nconst supportsStreams = typeof globals.ReadableStream === 'function';\nconst supportsFormData = typeof globals.FormData === 'function';\n\nconst mergeHeaders = (source1, source2) => {\n  const result = new globals.Headers(source1 || {});\n  const isHeadersInstance = source2 instanceof globals.Headers;\n  const source = new globals.Headers(source2 || {});\n\n  for (const [key, value] of source) {\n    if (isHeadersInstance && value === 'undefined' || value === undefined) {\n      result.delete(key);\n    } else {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n};\n\nconst deepMerge = (...sources) => {\n  let returnValue = {};\n  let headers = {};\n\n  for (const source of sources) {\n    if (Array.isArray(source)) {\n      if (!Array.isArray(returnValue)) {\n        returnValue = [];\n      }\n\n      returnValue = [...returnValue, ...source];\n    } else if (isObject(source)) {\n      for (let [key, value] of Object.entries(source)) {\n        if (isObject(value) && Reflect.has(returnValue, key)) {\n          value = deepMerge(returnValue[key], value);\n        }\n\n        returnValue = { ...returnValue,\n          [key]: value\n        };\n      }\n\n      if (isObject(source.headers)) {\n        headers = mergeHeaders(headers, source.headers);\n      }\n    }\n\n    returnValue.headers = headers;\n  }\n\n  return returnValue;\n};\n\nconst requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];\nconst responseTypes = {\n  json: 'application/json',\n  text: 'text/*',\n  formData: 'multipart/form-data',\n  arrayBuffer: '*/*',\n  blob: '*/*'\n};\nconst retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];\nconst retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];\nconst retryAfterStatusCodes = [413, 429, 503];\nconst stop = Symbol('stop');\n\nclass HTTPError extends Error {\n  constructor(response) {\n    // Set the message to the status text, such as Unauthorized,\n    // with some fallbacks. This message should never be undefined.\n    super(response.statusText || String(response.status === 0 || response.status ? response.status : 'Unknown response error'));\n    this.name = 'HTTPError';\n    this.response = response;\n  }\n\n}\n\nclass TimeoutError extends Error {\n  constructor(request) {\n    super('Request timed out');\n    this.name = 'TimeoutError';\n    this.request = request;\n  }\n\n}\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms)); // `Promise.race()` workaround (#91)\n\n\nconst timeout = (request, abortController, options) => new Promise((resolve, reject) => {\n  const timeoutID = setTimeout(() => {\n    if (abortController) {\n      abortController.abort();\n    }\n\n    reject(new TimeoutError(request));\n  }, options.timeout);\n  /* eslint-disable promise/prefer-await-to-then */\n\n  options.fetch(request).then(resolve).catch(reject).then(() => {\n    clearTimeout(timeoutID);\n  });\n  /* eslint-enable promise/prefer-await-to-then */\n});\n\nconst normalizeRequestMethod = input => requestMethods.includes(input) ? input.toUpperCase() : input;\n\nconst defaultRetryOptions = {\n  limit: 2,\n  methods: retryMethods,\n  statusCodes: retryStatusCodes,\n  afterStatusCodes: retryAfterStatusCodes\n};\n\nconst normalizeRetryOptions = (retry = {}) => {\n  if (typeof retry === 'number') {\n    return { ...defaultRetryOptions,\n      limit: retry\n    };\n  }\n\n  if (retry.methods && !Array.isArray(retry.methods)) {\n    throw new Error('retry.methods must be an array');\n  }\n\n  if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {\n    throw new Error('retry.statusCodes must be an array');\n  }\n\n  return { ...defaultRetryOptions,\n    ...retry,\n    afterStatusCodes: retryAfterStatusCodes\n  };\n}; // The maximum value of a 32bit int (see issue #117)\n\n\nconst maxSafeTimeout = 2147483647;\n\nclass Ky {\n  constructor(input, options = {}) {\n    this._retryCount = 0;\n    this._input = input;\n    this._options = {\n      // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208\n      credentials: this._input.credentials || 'same-origin',\n      ...options,\n      headers: mergeHeaders(this._input.headers, options.headers),\n      hooks: deepMerge({\n        beforeRequest: [],\n        beforeRetry: [],\n        afterResponse: []\n      }, options.hooks),\n      method: normalizeRequestMethod(options.method || this._input.method),\n      prefixUrl: String(options.prefixUrl || ''),\n      retry: normalizeRetryOptions(options.retry),\n      throwHttpErrors: options.throwHttpErrors !== false,\n      timeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,\n      fetch: options.fetch || globals.fetch\n    };\n\n    if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globals.Request)) {\n      throw new TypeError('`input` must be a string, URL, or Request');\n    }\n\n    if (this._options.prefixUrl && typeof this._input === 'string') {\n      if (this._input.startsWith('/')) {\n        throw new Error('`input` must not begin with a slash when using `prefixUrl`');\n      }\n\n      if (!this._options.prefixUrl.endsWith('/')) {\n        this._options.prefixUrl += '/';\n      }\n\n      this._input = this._options.prefixUrl + this._input;\n    }\n\n    if (supportsAbortController) {\n      this.abortController = new globals.AbortController();\n\n      if (this._options.signal) {\n        this._options.signal.addEventListener('abort', () => {\n          this.abortController.abort();\n        });\n      }\n\n      this._options.signal = this.abortController.signal;\n    }\n\n    this.request = new globals.Request(this._input, this._options);\n\n    if (this._options.searchParams) {\n      const searchParams = '?' + new URLSearchParams(this._options.searchParams).toString();\n      const url = this.request.url.replace(/(?:\\?.*?)?(?=#|$)/, searchParams); // To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one\n\n      if ((supportsFormData && this._options.body instanceof globals.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {\n        this.request.headers.delete('content-type');\n      }\n\n      this.request = new globals.Request(new globals.Request(url, this.request), this._options);\n    }\n\n    if (this._options.json !== undefined) {\n      this._options.body = JSON.stringify(this._options.json);\n      this.request.headers.set('content-type', 'application/json');\n      this.request = new globals.Request(this.request, {\n        body: this._options.body\n      });\n    }\n\n    const fn = async () => {\n      if (this._options.timeout > maxSafeTimeout) {\n        throw new RangeError(`The \\`timeout\\` option cannot be greater than ${maxSafeTimeout}`);\n      }\n\n      await delay(1);\n      let response = await this._fetch();\n\n      for (const hook of this._options.hooks.afterResponse) {\n        // eslint-disable-next-line no-await-in-loop\n        const modifiedResponse = await hook(this.request, this._options, response.clone());\n\n        if (modifiedResponse instanceof globals.Response) {\n          response = modifiedResponse;\n        }\n      }\n\n      if (!response.ok && this._options.throwHttpErrors) {\n        throw new HTTPError(response);\n      } // If `onDownloadProgress` is passed, it uses the stream API internally\n\n      /* istanbul ignore next */\n\n\n      if (this._options.onDownloadProgress) {\n        if (typeof this._options.onDownloadProgress !== 'function') {\n          throw new TypeError('The `onDownloadProgress` option must be a function');\n        }\n\n        if (!supportsStreams) {\n          throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');\n        }\n\n        return this._stream(response.clone(), this._options.onDownloadProgress);\n      }\n\n      if (this._options.parseJson) {\n        response.json = async () => {\n          return this._options.parseJson(await response.text());\n        };\n      }\n\n      return response;\n    };\n\n    const isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());\n\n    const result = isRetriableMethod ? this._retry(fn) : fn();\n\n    for (const [type, mimeType] of Object.entries(responseTypes)) {\n      result[type] = async () => {\n        this.request.headers.set('accept', this.request.headers.get('accept') || mimeType);\n        const response = (await result).clone();\n\n        if (type === 'json') {\n          if (response.status === 204) {\n            return '';\n          }\n\n          if (options.parseJson) {\n            return options.parseJson(await response.text());\n          }\n        }\n\n        return response[type]();\n      };\n    }\n\n    return result;\n  }\n\n  _calculateRetryDelay(error) {\n    this._retryCount++;\n\n    if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {\n      if (error instanceof HTTPError) {\n        if (!this._options.retry.statusCodes.includes(error.response.status)) {\n          return 0;\n        }\n\n        const retryAfter = error.response.headers.get('Retry-After');\n\n        if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {\n          let after = Number(retryAfter);\n\n          if (Number.isNaN(after)) {\n            after = Date.parse(retryAfter) - Date.now();\n          } else {\n            after *= 1000;\n          }\n\n          if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {\n            return 0;\n          }\n\n          return after;\n        }\n\n        if (error.response.status === 413) {\n          return 0;\n        }\n      }\n\n      const BACKOFF_FACTOR = 0.3;\n      return BACKOFF_FACTOR * 2 ** (this._retryCount - 1) * 1000;\n    }\n\n    return 0;\n  }\n\n  async _retry(fn) {\n    try {\n      return await fn();\n    } catch (error) {\n      const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);\n\n      if (ms !== 0 && this._retryCount > 0) {\n        await delay(ms);\n\n        for (const hook of this._options.hooks.beforeRetry) {\n          // eslint-disable-next-line no-await-in-loop\n          const hookResult = await hook({\n            request: this.request,\n            options: this._options,\n            error,\n            response: error.response.clone(),\n            retryCount: this._retryCount\n          }); // If `stop` is returned from the hook, the retry process is stopped\n\n          if (hookResult === stop) {\n            return;\n          }\n        }\n\n        return this._retry(fn);\n      }\n\n      if (this._options.throwHttpErrors) {\n        throw error;\n      }\n    }\n  }\n\n  async _fetch() {\n    for (const hook of this._options.hooks.beforeRequest) {\n      // eslint-disable-next-line no-await-in-loop\n      const result = await hook(this.request, this._options);\n\n      if (result instanceof Request) {\n        this.request = result;\n        break;\n      }\n\n      if (result instanceof Response) {\n        return result;\n      }\n    }\n\n    if (this._options.timeout === false) {\n      return this._options.fetch(this.request.clone());\n    }\n\n    return timeout(this.request.clone(), this.abortController, this._options);\n  }\n  /* istanbul ignore next */\n\n\n  _stream(response, onDownloadProgress) {\n    const totalBytes = Number(response.headers.get('content-length')) || 0;\n    let transferredBytes = 0;\n    return new globals.Response(new globals.ReadableStream({\n      start(controller) {\n        const reader = response.body.getReader();\n\n        if (onDownloadProgress) {\n          onDownloadProgress({\n            percent: 0,\n            transferredBytes: 0,\n            totalBytes\n          }, new Uint8Array());\n        }\n\n        async function read() {\n          const {\n            done,\n            value\n          } = await reader.read();\n\n          if (done) {\n            controller.close();\n            return;\n          }\n\n          if (onDownloadProgress) {\n            transferredBytes += value.byteLength;\n            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;\n            onDownloadProgress({\n              percent,\n              transferredBytes,\n              totalBytes\n            }, value);\n          }\n\n          controller.enqueue(value);\n          read();\n        }\n\n        read();\n      }\n\n    }));\n  }\n\n}\n\nconst validateAndMerge = (...sources) => {\n  for (const source of sources) {\n    if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n      throw new TypeError('The `options` argument must be an object');\n    }\n  }\n\n  return deepMerge({}, ...sources);\n};\n\nconst createInstance = defaults => {\n  const ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));\n\n  for (const method of requestMethods) {\n    ky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, {\n      method\n    }));\n  }\n\n  ky.HTTPError = HTTPError;\n  ky.TimeoutError = TimeoutError;\n\n  ky.create = newDefaults => createInstance(validateAndMerge(newDefaults));\n\n  ky.extend = newDefaults => createInstance(validateAndMerge(defaults, newDefaults));\n\n  ky.stop = stop;\n  return ky;\n};\n\nexport default createInstance();","map":{"version":3,"sources":["/home/abefernan/cosmwasm/dApps/node_modules/ky/index.js"],"names":["globals","getGlobal","property","self","window","global","globalThis","globalProperties","Object","defineProperty","get","globalObject","value","bind","isObject","supportsAbortController","AbortController","supportsStreams","ReadableStream","supportsFormData","FormData","mergeHeaders","source1","source2","result","Headers","isHeadersInstance","source","key","undefined","delete","set","deepMerge","sources","returnValue","headers","Array","isArray","entries","Reflect","has","requestMethods","responseTypes","json","text","formData","arrayBuffer","blob","retryMethods","retryStatusCodes","retryAfterStatusCodes","stop","Symbol","HTTPError","Error","constructor","response","statusText","String","status","name","TimeoutError","request","delay","ms","Promise","resolve","setTimeout","timeout","abortController","options","reject","timeoutID","abort","fetch","then","catch","clearTimeout","normalizeRequestMethod","input","includes","toUpperCase","defaultRetryOptions","limit","methods","statusCodes","afterStatusCodes","normalizeRetryOptions","retry","maxSafeTimeout","Ky","_retryCount","_input","_options","credentials","hooks","beforeRequest","beforeRetry","afterResponse","method","prefixUrl","throwHttpErrors","URL","Request","TypeError","startsWith","endsWith","signal","addEventListener","searchParams","URLSearchParams","toString","url","replace","body","JSON","stringify","fn","RangeError","_fetch","hook","modifiedResponse","clone","Response","ok","onDownloadProgress","_stream","parseJson","isRetriableMethod","toLowerCase","_retry","type","mimeType","_calculateRetryDelay","error","retryAfter","after","Number","isNaN","Date","parse","now","maxRetryAfter","BACKOFF_FACTOR","Math","min","hookResult","retryCount","totalBytes","transferredBytes","start","controller","reader","getReader","percent","Uint8Array","read","done","close","byteLength","enqueue","validateAndMerge","createInstance","defaults","ky","create","newDefaults","extend"],"mappings":"AAAA;AAEA,MAAMA,OAAO,GAAG,EAAhB;;AAEA,MAAMC,SAAS,GAAGC,QAAQ,IAAI;AAC7B;AACA,MAAI,OAAOC,IAAP,KAAgB,WAAhB,IAA+BA,IAA/B,IAAuCD,QAAQ,IAAIC,IAAvD,EAA6D;AAC5D,WAAOA,IAAP;AACA;AAED;;;AACA,MAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAjC,IAA2CF,QAAQ,IAAIE,MAA3D,EAAmE;AAClE,WAAOA,MAAP;AACA;;AAED,MAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAjC,IAA2CH,QAAQ,IAAIG,MAA3D,EAAmE;AAClE,WAAOA,MAAP;AACA;AAED;;;AACA,MAAI,OAAOC,UAAP,KAAsB,WAAtB,IAAqCA,UAAzC,EAAqD;AACpD,WAAOA,UAAP;AACA;AACD,CAnBD;;AAqBA,MAAMC,gBAAgB,GAAG,CACxB,SADwB,EAExB,SAFwB,EAGxB,UAHwB,EAIxB,gBAJwB,EAKxB,OALwB,EAMxB,iBANwB,EAOxB,UAPwB,CAAzB;;AAUA,KAAK,MAAML,QAAX,IAAuBK,gBAAvB,EAAyC;AACxCC,EAAAA,MAAM,CAACC,cAAP,CAAsBT,OAAtB,EAA+BE,QAA/B,EAAyC;AACxCQ,IAAAA,GAAG,GAAG;AACL,YAAMC,YAAY,GAAGV,SAAS,CAACC,QAAD,CAA9B;AACA,YAAMU,KAAK,GAAGD,YAAY,IAAIA,YAAY,CAACT,QAAD,CAA1C;AACA,aAAO,OAAOU,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,CAACC,IAAN,CAAWF,YAAX,CAA9B,GAAyDC,KAAhE;AACA;;AALuC,GAAzC;AAOA;;AAED,MAAME,QAAQ,GAAGF,KAAK,IAAIA,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,QAA7D;;AACA,MAAMG,uBAAuB,GAAG,OAAOf,OAAO,CAACgB,eAAf,KAAmC,UAAnE;AACA,MAAMC,eAAe,GAAG,OAAOjB,OAAO,CAACkB,cAAf,KAAkC,UAA1D;AACA,MAAMC,gBAAgB,GAAG,OAAOnB,OAAO,CAACoB,QAAf,KAA4B,UAArD;;AAEA,MAAMC,YAAY,GAAG,CAACC,OAAD,EAAUC,OAAV,KAAsB;AAC1C,QAAMC,MAAM,GAAG,IAAIxB,OAAO,CAACyB,OAAZ,CAAoBH,OAAO,IAAI,EAA/B,CAAf;AACA,QAAMI,iBAAiB,GAAGH,OAAO,YAAYvB,OAAO,CAACyB,OAArD;AACA,QAAME,MAAM,GAAG,IAAI3B,OAAO,CAACyB,OAAZ,CAAoBF,OAAO,IAAI,EAA/B,CAAf;;AAEA,OAAK,MAAM,CAACK,GAAD,EAAMhB,KAAN,CAAX,IAA2Be,MAA3B,EAAmC;AAClC,QAAKD,iBAAiB,IAAId,KAAK,KAAK,WAAhC,IAAgDA,KAAK,KAAKiB,SAA9D,EAAyE;AACxEL,MAAAA,MAAM,CAACM,MAAP,CAAcF,GAAd;AACA,KAFD,MAEO;AACNJ,MAAAA,MAAM,CAACO,GAAP,CAAWH,GAAX,EAAgBhB,KAAhB;AACA;AACD;;AAED,SAAOY,MAAP;AACA,CAdD;;AAgBA,MAAMQ,SAAS,GAAG,CAAC,GAAGC,OAAJ,KAAgB;AACjC,MAAIC,WAAW,GAAG,EAAlB;AACA,MAAIC,OAAO,GAAG,EAAd;;AAEA,OAAK,MAAMR,MAAX,IAAqBM,OAArB,EAA8B;AAC7B,QAAIG,KAAK,CAACC,OAAN,CAAcV,MAAd,CAAJ,EAA2B;AAC1B,UAAI,CAAES,KAAK,CAACC,OAAN,CAAcH,WAAd,CAAN,EAAmC;AAClCA,QAAAA,WAAW,GAAG,EAAd;AACA;;AAEDA,MAAAA,WAAW,GAAG,CAAC,GAAGA,WAAJ,EAAiB,GAAGP,MAApB,CAAd;AACA,KAND,MAMO,IAAIb,QAAQ,CAACa,MAAD,CAAZ,EAAsB;AAC5B,WAAK,IAAI,CAACC,GAAD,EAAMhB,KAAN,CAAT,IAAyBJ,MAAM,CAAC8B,OAAP,CAAeX,MAAf,CAAzB,EAAiD;AAChD,YAAIb,QAAQ,CAACF,KAAD,CAAR,IAAmB2B,OAAO,CAACC,GAAR,CAAYN,WAAZ,EAAyBN,GAAzB,CAAvB,EAAsD;AACrDhB,UAAAA,KAAK,GAAGoB,SAAS,CAACE,WAAW,CAACN,GAAD,CAAZ,EAAmBhB,KAAnB,CAAjB;AACA;;AAEDsB,QAAAA,WAAW,GAAG,EAAC,GAAGA,WAAJ;AAAiB,WAACN,GAAD,GAAOhB;AAAxB,SAAd;AACA;;AAED,UAAIE,QAAQ,CAACa,MAAM,CAACQ,OAAR,CAAZ,EAA8B;AAC7BA,QAAAA,OAAO,GAAGd,YAAY,CAACc,OAAD,EAAUR,MAAM,CAACQ,OAAjB,CAAtB;AACA;AACD;;AAEDD,IAAAA,WAAW,CAACC,OAAZ,GAAsBA,OAAtB;AACA;;AAED,SAAOD,WAAP;AACA,CA7BD;;AA+BA,MAAMO,cAAc,GAAG,CACtB,KADsB,EAEtB,MAFsB,EAGtB,KAHsB,EAItB,OAJsB,EAKtB,MALsB,EAMtB,QANsB,CAAvB;AASA,MAAMC,aAAa,GAAG;AACrBC,EAAAA,IAAI,EAAE,kBADe;AAErBC,EAAAA,IAAI,EAAE,QAFe;AAGrBC,EAAAA,QAAQ,EAAE,qBAHW;AAIrBC,EAAAA,WAAW,EAAE,KAJQ;AAKrBC,EAAAA,IAAI,EAAE;AALe,CAAtB;AAQA,MAAMC,YAAY,GAAG,CACpB,KADoB,EAEpB,KAFoB,EAGpB,MAHoB,EAIpB,QAJoB,EAKpB,SALoB,EAMpB,OANoB,CAArB;AASA,MAAMC,gBAAgB,GAAG,CACxB,GADwB,EAExB,GAFwB,EAGxB,GAHwB,EAIxB,GAJwB,EAKxB,GALwB,EAMxB,GANwB,EAOxB,GAPwB,CAAzB;AAUA,MAAMC,qBAAqB,GAAG,CAC7B,GAD6B,EAE7B,GAF6B,EAG7B,GAH6B,CAA9B;AAMA,MAAMC,IAAI,GAAGC,MAAM,CAAC,MAAD,CAAnB;;AAEA,MAAMC,SAAN,SAAwBC,KAAxB,CAA8B;AAC7BC,EAAAA,WAAW,CAACC,QAAD,EAAW;AACrB;AACA;AACA,UACCA,QAAQ,CAACC,UAAT,IACAC,MAAM,CACJF,QAAQ,CAACG,MAAT,KAAoB,CAApB,IAAyBH,QAAQ,CAACG,MAAnC,GACCH,QAAQ,CAACG,MADV,GACmB,wBAFd,CAFP;AAOA,SAAKC,IAAL,GAAY,WAAZ;AACA,SAAKJ,QAAL,GAAgBA,QAAhB;AACA;;AAb4B;;AAgB9B,MAAMK,YAAN,SAA2BP,KAA3B,CAAiC;AAChCC,EAAAA,WAAW,CAACO,OAAD,EAAU;AACpB,UAAM,mBAAN;AACA,SAAKF,IAAL,GAAY,cAAZ;AACA,SAAKE,OAAL,GAAeA,OAAf;AACA;;AAL+B;;AAQjC,MAAMC,KAAK,GAAGC,EAAE,IAAI,IAAIC,OAAJ,CAAYC,OAAO,IAAIC,UAAU,CAACD,OAAD,EAAUF,EAAV,CAAjC,CAApB,C,CAEA;;;AACA,MAAMI,OAAO,GAAG,CAACN,OAAD,EAAUO,eAAV,EAA2BC,OAA3B,KACf,IAAIL,OAAJ,CAAY,CAACC,OAAD,EAAUK,MAAV,KAAqB;AAChC,QAAMC,SAAS,GAAGL,UAAU,CAAC,MAAM;AAClC,QAAIE,eAAJ,EAAqB;AACpBA,MAAAA,eAAe,CAACI,KAAhB;AACA;;AAEDF,IAAAA,MAAM,CAAC,IAAIV,YAAJ,CAAiBC,OAAjB,CAAD,CAAN;AACA,GAN2B,EAMzBQ,OAAO,CAACF,OANiB,CAA5B;AAQA;;AACAE,EAAAA,OAAO,CAACI,KAAR,CAAcZ,OAAd,EACEa,IADF,CACOT,OADP,EAEEU,KAFF,CAEQL,MAFR,EAGEI,IAHF,CAGO,MAAM;AACXE,IAAAA,YAAY,CAACL,SAAD,CAAZ;AACA,GALF;AAMA;AACA,CAjBD,CADD;;AAoBA,MAAMM,sBAAsB,GAAGC,KAAK,IAAItC,cAAc,CAACuC,QAAf,CAAwBD,KAAxB,IAAiCA,KAAK,CAACE,WAAN,EAAjC,GAAuDF,KAA/F;;AAEA,MAAMG,mBAAmB,GAAG;AAC3BC,EAAAA,KAAK,EAAE,CADoB;AAE3BC,EAAAA,OAAO,EAAEpC,YAFkB;AAG3BqC,EAAAA,WAAW,EAAEpC,gBAHc;AAI3BqC,EAAAA,gBAAgB,EAAEpC;AAJS,CAA5B;;AAOA,MAAMqC,qBAAqB,GAAG,CAACC,KAAK,GAAG,EAAT,KAAgB;AAC7C,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC9B,WAAO,EACN,GAAGN,mBADG;AAENC,MAAAA,KAAK,EAAEK;AAFD,KAAP;AAIA;;AAED,MAAIA,KAAK,CAACJ,OAAN,IAAiB,CAAChD,KAAK,CAACC,OAAN,CAAcmD,KAAK,CAACJ,OAApB,CAAtB,EAAoD;AACnD,UAAM,IAAI9B,KAAJ,CAAU,gCAAV,CAAN;AACA;;AAED,MAAIkC,KAAK,CAACH,WAAN,IAAqB,CAACjD,KAAK,CAACC,OAAN,CAAcmD,KAAK,CAACH,WAApB,CAA1B,EAA4D;AAC3D,UAAM,IAAI/B,KAAJ,CAAU,oCAAV,CAAN;AACA;;AAED,SAAO,EACN,GAAG4B,mBADG;AAEN,OAAGM,KAFG;AAGNF,IAAAA,gBAAgB,EAAEpC;AAHZ,GAAP;AAKA,CArBD,C,CAuBA;;;AACA,MAAMuC,cAAc,GAAG,UAAvB;;AAEA,MAAMC,EAAN,CAAS;AACRnC,EAAAA,WAAW,CAACwB,KAAD,EAAQT,OAAO,GAAG,EAAlB,EAAsB;AAChC,SAAKqB,WAAL,GAAmB,CAAnB;AACA,SAAKC,MAAL,GAAcb,KAAd;AACA,SAAKc,QAAL,GAAgB;AACf;AACAC,MAAAA,WAAW,EAAE,KAAKF,MAAL,CAAYE,WAAZ,IAA2B,aAFzB;AAGf,SAAGxB,OAHY;AAIfnC,MAAAA,OAAO,EAAEd,YAAY,CAAC,KAAKuE,MAAL,CAAYzD,OAAb,EAAsBmC,OAAO,CAACnC,OAA9B,CAJN;AAKf4D,MAAAA,KAAK,EAAE/D,SAAS,CAAC;AAChBgE,QAAAA,aAAa,EAAE,EADC;AAEhBC,QAAAA,WAAW,EAAE,EAFG;AAGhBC,QAAAA,aAAa,EAAE;AAHC,OAAD,EAIb5B,OAAO,CAACyB,KAJK,CALD;AAUfI,MAAAA,MAAM,EAAErB,sBAAsB,CAACR,OAAO,CAAC6B,MAAR,IAAkB,KAAKP,MAAL,CAAYO,MAA/B,CAVf;AAWfC,MAAAA,SAAS,EAAE1C,MAAM,CAACY,OAAO,CAAC8B,SAAR,IAAqB,EAAtB,CAXF;AAYfZ,MAAAA,KAAK,EAAED,qBAAqB,CAACjB,OAAO,CAACkB,KAAT,CAZb;AAafa,MAAAA,eAAe,EAAE/B,OAAO,CAAC+B,eAAR,KAA4B,KAb9B;AAcfjC,MAAAA,OAAO,EAAE,OAAOE,OAAO,CAACF,OAAf,KAA2B,WAA3B,GAAyC,KAAzC,GAAiDE,OAAO,CAACF,OAdnD;AAefM,MAAAA,KAAK,EAAEJ,OAAO,CAACI,KAAR,IAAiB1E,OAAO,CAAC0E;AAfjB,KAAhB;;AAkBA,QAAI,OAAO,KAAKkB,MAAZ,KAAuB,QAAvB,IAAmC,EAAE,KAAKA,MAAL,YAAuBU,GAAvB,IAA8B,KAAKV,MAAL,YAAuB5F,OAAO,CAACuG,OAA/D,CAAvC,EAAgH;AAC/G,YAAM,IAAIC,SAAJ,CAAc,2CAAd,CAAN;AACA;;AAED,QAAI,KAAKX,QAAL,CAAcO,SAAd,IAA2B,OAAO,KAAKR,MAAZ,KAAuB,QAAtD,EAAgE;AAC/D,UAAI,KAAKA,MAAL,CAAYa,UAAZ,CAAuB,GAAvB,CAAJ,EAAiC;AAChC,cAAM,IAAInD,KAAJ,CAAU,4DAAV,CAAN;AACA;;AAED,UAAI,CAAC,KAAKuC,QAAL,CAAcO,SAAd,CAAwBM,QAAxB,CAAiC,GAAjC,CAAL,EAA4C;AAC3C,aAAKb,QAAL,CAAcO,SAAd,IAA2B,GAA3B;AACA;;AAED,WAAKR,MAAL,GAAc,KAAKC,QAAL,CAAcO,SAAd,GAA0B,KAAKR,MAA7C;AACA;;AAED,QAAI7E,uBAAJ,EAA6B;AAC5B,WAAKsD,eAAL,GAAuB,IAAIrE,OAAO,CAACgB,eAAZ,EAAvB;;AACA,UAAI,KAAK6E,QAAL,CAAcc,MAAlB,EAA0B;AACzB,aAAKd,QAAL,CAAcc,MAAd,CAAqBC,gBAArB,CAAsC,OAAtC,EAA+C,MAAM;AACpD,eAAKvC,eAAL,CAAqBI,KAArB;AACA,SAFD;AAGA;;AAED,WAAKoB,QAAL,CAAcc,MAAd,GAAuB,KAAKtC,eAAL,CAAqBsC,MAA5C;AACA;;AAED,SAAK7C,OAAL,GAAe,IAAI9D,OAAO,CAACuG,OAAZ,CAAoB,KAAKX,MAAzB,EAAiC,KAAKC,QAAtC,CAAf;;AAEA,QAAI,KAAKA,QAAL,CAAcgB,YAAlB,EAAgC;AAC/B,YAAMA,YAAY,GAAG,MAAM,IAAIC,eAAJ,CAAoB,KAAKjB,QAAL,CAAcgB,YAAlC,EAAgDE,QAAhD,EAA3B;AACA,YAAMC,GAAG,GAAG,KAAKlD,OAAL,CAAakD,GAAb,CAAiBC,OAAjB,CAAyB,mBAAzB,EAA8CJ,YAA9C,CAAZ,CAF+B,CAI/B;;AACA,UAAI,CAAE1F,gBAAgB,IAAI,KAAK0E,QAAL,CAAcqB,IAAd,YAA8BlH,OAAO,CAACoB,QAA3D,IAAwE,KAAKyE,QAAL,CAAcqB,IAAd,YAA8BJ,eAAvG,KAA2H,EAAE,KAAKjB,QAAL,CAAc1D,OAAd,IAAyB,KAAK0D,QAAL,CAAc1D,OAAd,CAAsB,cAAtB,CAA3B,CAA/H,EAAkM;AACjM,aAAK2B,OAAL,CAAa3B,OAAb,CAAqBL,MAArB,CAA4B,cAA5B;AACA;;AAED,WAAKgC,OAAL,GAAe,IAAI9D,OAAO,CAACuG,OAAZ,CAAoB,IAAIvG,OAAO,CAACuG,OAAZ,CAAoBS,GAApB,EAAyB,KAAKlD,OAA9B,CAApB,EAA4D,KAAK+B,QAAjE,CAAf;AACA;;AAED,QAAI,KAAKA,QAAL,CAAclD,IAAd,KAAuBd,SAA3B,EAAsC;AACrC,WAAKgE,QAAL,CAAcqB,IAAd,GAAqBC,IAAI,CAACC,SAAL,CAAe,KAAKvB,QAAL,CAAclD,IAA7B,CAArB;AACA,WAAKmB,OAAL,CAAa3B,OAAb,CAAqBJ,GAArB,CAAyB,cAAzB,EAAyC,kBAAzC;AACA,WAAK+B,OAAL,GAAe,IAAI9D,OAAO,CAACuG,OAAZ,CAAoB,KAAKzC,OAAzB,EAAkC;AAACoD,QAAAA,IAAI,EAAE,KAAKrB,QAAL,CAAcqB;AAArB,OAAlC,CAAf;AACA;;AAED,UAAMG,EAAE,GAAG,YAAY;AACtB,UAAI,KAAKxB,QAAL,CAAczB,OAAd,GAAwBqB,cAA5B,EAA4C;AAC3C,cAAM,IAAI6B,UAAJ,CAAgB,iDAAgD7B,cAAe,EAA/E,CAAN;AACA;;AAED,YAAM1B,KAAK,CAAC,CAAD,CAAX;AACA,UAAIP,QAAQ,GAAG,MAAM,KAAK+D,MAAL,EAArB;;AAEA,WAAK,MAAMC,IAAX,IAAmB,KAAK3B,QAAL,CAAcE,KAAd,CAAoBG,aAAvC,EAAsD;AACrD;AACA,cAAMuB,gBAAgB,GAAG,MAAMD,IAAI,CAClC,KAAK1D,OAD6B,EAElC,KAAK+B,QAF6B,EAGlCrC,QAAQ,CAACkE,KAAT,EAHkC,CAAnC;;AAMA,YAAID,gBAAgB,YAAYzH,OAAO,CAAC2H,QAAxC,EAAkD;AACjDnE,UAAAA,QAAQ,GAAGiE,gBAAX;AACA;AACD;;AAED,UAAI,CAACjE,QAAQ,CAACoE,EAAV,IAAgB,KAAK/B,QAAL,CAAcQ,eAAlC,EAAmD;AAClD,cAAM,IAAIhD,SAAJ,CAAcG,QAAd,CAAN;AACA,OAvBqB,CAyBtB;;AACA;;;AACA,UAAI,KAAKqC,QAAL,CAAcgC,kBAAlB,EAAsC;AACrC,YAAI,OAAO,KAAKhC,QAAL,CAAcgC,kBAArB,KAA4C,UAAhD,EAA4D;AAC3D,gBAAM,IAAIrB,SAAJ,CAAc,oDAAd,CAAN;AACA;;AAED,YAAI,CAACvF,eAAL,EAAsB;AACrB,gBAAM,IAAIqC,KAAJ,CAAU,6EAAV,CAAN;AACA;;AAED,eAAO,KAAKwE,OAAL,CAAatE,QAAQ,CAACkE,KAAT,EAAb,EAA+B,KAAK7B,QAAL,CAAcgC,kBAA7C,CAAP;AACA;;AAED,UAAI,KAAKhC,QAAL,CAAckC,SAAlB,EAA6B;AAC5BvE,QAAAA,QAAQ,CAACb,IAAT,GAAgB,YAAY;AAC3B,iBAAO,KAAKkD,QAAL,CAAckC,SAAd,CAAwB,MAAMvE,QAAQ,CAACZ,IAAT,EAA9B,CAAP;AACA,SAFD;AAGA;;AAED,aAAOY,QAAP;AACA,KA9CD;;AAgDA,UAAMwE,iBAAiB,GAAG,KAAKnC,QAAL,CAAcL,KAAd,CAAoBJ,OAApB,CAA4BJ,QAA5B,CAAqC,KAAKlB,OAAL,CAAaqC,MAAb,CAAoB8B,WAApB,EAArC,CAA1B;;AACA,UAAMzG,MAAM,GAAGwG,iBAAiB,GAAG,KAAKE,MAAL,CAAYb,EAAZ,CAAH,GAAqBA,EAAE,EAAvD;;AAEA,SAAK,MAAM,CAACc,IAAD,EAAOC,QAAP,CAAX,IAA+B5H,MAAM,CAAC8B,OAAP,CAAeI,aAAf,CAA/B,EAA8D;AAC7DlB,MAAAA,MAAM,CAAC2G,IAAD,CAAN,GAAe,YAAY;AAC1B,aAAKrE,OAAL,CAAa3B,OAAb,CAAqBJ,GAArB,CAAyB,QAAzB,EAAmC,KAAK+B,OAAL,CAAa3B,OAAb,CAAqBzB,GAArB,CAAyB,QAAzB,KAAsC0H,QAAzE;AAEA,cAAM5E,QAAQ,GAAG,CAAC,MAAMhC,MAAP,EAAekG,KAAf,EAAjB;;AAEA,YAAIS,IAAI,KAAK,MAAb,EAAqB;AACpB,cAAI3E,QAAQ,CAACG,MAAT,KAAoB,GAAxB,EAA6B;AAC5B,mBAAO,EAAP;AACA;;AAED,cAAIW,OAAO,CAACyD,SAAZ,EAAuB;AACtB,mBAAOzD,OAAO,CAACyD,SAAR,CAAkB,MAAMvE,QAAQ,CAACZ,IAAT,EAAxB,CAAP;AACA;AACD;;AAED,eAAOY,QAAQ,CAAC2E,IAAD,CAAR,EAAP;AACA,OAhBD;AAiBA;;AAED,WAAO3G,MAAP;AACA;;AAED6G,EAAAA,oBAAoB,CAACC,KAAD,EAAQ;AAC3B,SAAK3C,WAAL;;AAEA,QAAI,KAAKA,WAAL,GAAmB,KAAKE,QAAL,CAAcL,KAAd,CAAoBL,KAAvC,IAAgD,EAAEmD,KAAK,YAAYzE,YAAnB,CAApD,EAAsF;AACrF,UAAIyE,KAAK,YAAYjF,SAArB,EAAgC;AAC/B,YAAI,CAAC,KAAKwC,QAAL,CAAcL,KAAd,CAAoBH,WAApB,CAAgCL,QAAhC,CAAyCsD,KAAK,CAAC9E,QAAN,CAAeG,MAAxD,CAAL,EAAsE;AACrE,iBAAO,CAAP;AACA;;AAED,cAAM4E,UAAU,GAAGD,KAAK,CAAC9E,QAAN,CAAerB,OAAf,CAAuBzB,GAAvB,CAA2B,aAA3B,CAAnB;;AACA,YAAI6H,UAAU,IAAI,KAAK1C,QAAL,CAAcL,KAAd,CAAoBF,gBAApB,CAAqCN,QAArC,CAA8CsD,KAAK,CAAC9E,QAAN,CAAeG,MAA7D,CAAlB,EAAwF;AACvF,cAAI6E,KAAK,GAAGC,MAAM,CAACF,UAAD,CAAlB;;AACA,cAAIE,MAAM,CAACC,KAAP,CAAaF,KAAb,CAAJ,EAAyB;AACxBA,YAAAA,KAAK,GAAGG,IAAI,CAACC,KAAL,CAAWL,UAAX,IAAyBI,IAAI,CAACE,GAAL,EAAjC;AACA,WAFD,MAEO;AACNL,YAAAA,KAAK,IAAI,IAAT;AACA;;AAED,cAAI,OAAO,KAAK3C,QAAL,CAAcL,KAAd,CAAoBsD,aAA3B,KAA6C,WAA7C,IAA4DN,KAAK,GAAG,KAAK3C,QAAL,CAAcL,KAAd,CAAoBsD,aAA5F,EAA2G;AAC1G,mBAAO,CAAP;AACA;;AAED,iBAAON,KAAP;AACA;;AAED,YAAIF,KAAK,CAAC9E,QAAN,CAAeG,MAAf,KAA0B,GAA9B,EAAmC;AAClC,iBAAO,CAAP;AACA;AACD;;AAED,YAAMoF,cAAc,GAAG,GAAvB;AACA,aAAOA,cAAc,GAAI,MAAM,KAAKpD,WAAL,GAAmB,CAAzB,CAAlB,GAAiD,IAAxD;AACA;;AAED,WAAO,CAAP;AACA;;AAED,QAAMuC,MAAN,CAAab,EAAb,EAAiB;AAChB,QAAI;AACH,aAAO,MAAMA,EAAE,EAAf;AACA,KAFD,CAEE,OAAOiB,KAAP,EAAc;AACf,YAAMtE,EAAE,GAAGgF,IAAI,CAACC,GAAL,CAAS,KAAKZ,oBAAL,CAA0BC,KAA1B,CAAT,EAA2C7C,cAA3C,CAAX;;AACA,UAAIzB,EAAE,KAAK,CAAP,IAAY,KAAK2B,WAAL,GAAmB,CAAnC,EAAsC;AACrC,cAAM5B,KAAK,CAACC,EAAD,CAAX;;AAEA,aAAK,MAAMwD,IAAX,IAAmB,KAAK3B,QAAL,CAAcE,KAAd,CAAoBE,WAAvC,EAAoD;AACnD;AACA,gBAAMiD,UAAU,GAAG,MAAM1B,IAAI,CAAC;AAC7B1D,YAAAA,OAAO,EAAE,KAAKA,OADe;AAE7BQ,YAAAA,OAAO,EAAE,KAAKuB,QAFe;AAG7ByC,YAAAA,KAH6B;AAI7B9E,YAAAA,QAAQ,EAAE8E,KAAK,CAAC9E,QAAN,CAAekE,KAAf,EAJmB;AAK7ByB,YAAAA,UAAU,EAAE,KAAKxD;AALY,WAAD,CAA7B,CAFmD,CAUnD;;AACA,cAAIuD,UAAU,KAAK/F,IAAnB,EAAyB;AACxB;AACA;AACD;;AAED,eAAO,KAAK+E,MAAL,CAAYb,EAAZ,CAAP;AACA;;AAED,UAAI,KAAKxB,QAAL,CAAcQ,eAAlB,EAAmC;AAClC,cAAMiC,KAAN;AACA;AACD;AACD;;AAED,QAAMf,MAAN,GAAe;AACd,SAAK,MAAMC,IAAX,IAAmB,KAAK3B,QAAL,CAAcE,KAAd,CAAoBC,aAAvC,EAAsD;AACrD;AACA,YAAMxE,MAAM,GAAG,MAAMgG,IAAI,CAAC,KAAK1D,OAAN,EAAe,KAAK+B,QAApB,CAAzB;;AAEA,UAAIrE,MAAM,YAAY+E,OAAtB,EAA+B;AAC9B,aAAKzC,OAAL,GAAetC,MAAf;AACA;AACA;;AAED,UAAIA,MAAM,YAAYmG,QAAtB,EAAgC;AAC/B,eAAOnG,MAAP;AACA;AACD;;AAED,QAAI,KAAKqE,QAAL,CAAczB,OAAd,KAA0B,KAA9B,EAAqC;AACpC,aAAO,KAAKyB,QAAL,CAAcnB,KAAd,CAAoB,KAAKZ,OAAL,CAAa4D,KAAb,EAApB,CAAP;AACA;;AAED,WAAOtD,OAAO,CAAC,KAAKN,OAAL,CAAa4D,KAAb,EAAD,EAAuB,KAAKrD,eAA5B,EAA6C,KAAKwB,QAAlD,CAAd;AACA;AAED;;;AACAiC,EAAAA,OAAO,CAACtE,QAAD,EAAWqE,kBAAX,EAA+B;AACrC,UAAMuB,UAAU,GAAGX,MAAM,CAACjF,QAAQ,CAACrB,OAAT,CAAiBzB,GAAjB,CAAqB,gBAArB,CAAD,CAAN,IAAkD,CAArE;AACA,QAAI2I,gBAAgB,GAAG,CAAvB;AAEA,WAAO,IAAIrJ,OAAO,CAAC2H,QAAZ,CACN,IAAI3H,OAAO,CAACkB,cAAZ,CAA2B;AAC1BoI,MAAAA,KAAK,CAACC,UAAD,EAAa;AACjB,cAAMC,MAAM,GAAGhG,QAAQ,CAAC0D,IAAT,CAAcuC,SAAd,EAAf;;AAEA,YAAI5B,kBAAJ,EAAwB;AACvBA,UAAAA,kBAAkB,CAAC;AAAC6B,YAAAA,OAAO,EAAE,CAAV;AAAaL,YAAAA,gBAAgB,EAAE,CAA/B;AAAkCD,YAAAA;AAAlC,WAAD,EAAgD,IAAIO,UAAJ,EAAhD,CAAlB;AACA;;AAED,uBAAeC,IAAf,GAAsB;AACrB,gBAAM;AAACC,YAAAA,IAAD;AAAOjJ,YAAAA;AAAP,cAAgB,MAAM4I,MAAM,CAACI,IAAP,EAA5B;;AACA,cAAIC,IAAJ,EAAU;AACTN,YAAAA,UAAU,CAACO,KAAX;AACA;AACA;;AAED,cAAIjC,kBAAJ,EAAwB;AACvBwB,YAAAA,gBAAgB,IAAIzI,KAAK,CAACmJ,UAA1B;AACA,kBAAML,OAAO,GAAGN,UAAU,KAAK,CAAf,GAAmB,CAAnB,GAAuBC,gBAAgB,GAAGD,UAA1D;AACAvB,YAAAA,kBAAkB,CAAC;AAAC6B,cAAAA,OAAD;AAAUL,cAAAA,gBAAV;AAA4BD,cAAAA;AAA5B,aAAD,EAA0CxI,KAA1C,CAAlB;AACA;;AAED2I,UAAAA,UAAU,CAACS,OAAX,CAAmBpJ,KAAnB;AACAgJ,UAAAA,IAAI;AACJ;;AAEDA,QAAAA,IAAI;AACJ;;AA1ByB,KAA3B,CADM,CAAP;AA8BA;;AA9QO;;AAiRT,MAAMK,gBAAgB,GAAG,CAAC,GAAGhI,OAAJ,KAAgB;AACxC,OAAK,MAAMN,MAAX,IAAqBM,OAArB,EAA8B;AAC7B,QAAI,CAAC,CAACnB,QAAQ,CAACa,MAAD,CAAT,IAAqBS,KAAK,CAACC,OAAN,CAAcV,MAAd,CAAtB,KAAgD,OAAOA,MAAP,KAAkB,WAAtE,EAAmF;AAClF,YAAM,IAAI6E,SAAJ,CAAc,0CAAd,CAAN;AACA;AACD;;AAED,SAAOxE,SAAS,CAAC,EAAD,EAAK,GAAGC,OAAR,CAAhB;AACA,CARD;;AAUA,MAAMiI,cAAc,GAAGC,QAAQ,IAAI;AAClC,QAAMC,EAAE,GAAG,CAACrF,KAAD,EAAQT,OAAR,KAAoB,IAAIoB,EAAJ,CAAOX,KAAP,EAAckF,gBAAgB,CAACE,QAAD,EAAW7F,OAAX,CAA9B,CAA/B;;AAEA,OAAK,MAAM6B,MAAX,IAAqB1D,cAArB,EAAqC;AACpC2H,IAAAA,EAAE,CAACjE,MAAD,CAAF,GAAa,CAACpB,KAAD,EAAQT,OAAR,KAAoB,IAAIoB,EAAJ,CAAOX,KAAP,EAAckF,gBAAgB,CAACE,QAAD,EAAW7F,OAAX,EAAoB;AAAC6B,MAAAA;AAAD,KAApB,CAA9B,CAAjC;AACA;;AAEDiE,EAAAA,EAAE,CAAC/G,SAAH,GAAeA,SAAf;AACA+G,EAAAA,EAAE,CAACvG,YAAH,GAAkBA,YAAlB;;AACAuG,EAAAA,EAAE,CAACC,MAAH,GAAYC,WAAW,IAAIJ,cAAc,CAACD,gBAAgB,CAACK,WAAD,CAAjB,CAAzC;;AACAF,EAAAA,EAAE,CAACG,MAAH,GAAYD,WAAW,IAAIJ,cAAc,CAACD,gBAAgB,CAACE,QAAD,EAAWG,WAAX,CAAjB,CAAzC;;AACAF,EAAAA,EAAE,CAACjH,IAAH,GAAUA,IAAV;AAEA,SAAOiH,EAAP;AACA,CAdD;;AAgBA,eAAeF,cAAc,EAA7B","sourcesContent":["/*! MIT License © Sindre Sorhus */\n\nconst globals = {};\n\nconst getGlobal = property => {\n\t/* istanbul ignore next */\n\tif (typeof self !== 'undefined' && self && property in self) {\n\t\treturn self;\n\t}\n\n\t/* istanbul ignore next */\n\tif (typeof window !== 'undefined' && window && property in window) {\n\t\treturn window;\n\t}\n\n\tif (typeof global !== 'undefined' && global && property in global) {\n\t\treturn global;\n\t}\n\n\t/* istanbul ignore next */\n\tif (typeof globalThis !== 'undefined' && globalThis) {\n\t\treturn globalThis;\n\t}\n};\n\nconst globalProperties = [\n\t'Headers',\n\t'Request',\n\t'Response',\n\t'ReadableStream',\n\t'fetch',\n\t'AbortController',\n\t'FormData'\n];\n\nfor (const property of globalProperties) {\n\tObject.defineProperty(globals, property, {\n\t\tget() {\n\t\t\tconst globalObject = getGlobal(property);\n\t\t\tconst value = globalObject && globalObject[property];\n\t\t\treturn typeof value === 'function' ? value.bind(globalObject) : value;\n\t\t}\n\t});\n}\n\nconst isObject = value => value !== null && typeof value === 'object';\nconst supportsAbortController = typeof globals.AbortController === 'function';\nconst supportsStreams = typeof globals.ReadableStream === 'function';\nconst supportsFormData = typeof globals.FormData === 'function';\n\nconst mergeHeaders = (source1, source2) => {\n\tconst result = new globals.Headers(source1 || {});\n\tconst isHeadersInstance = source2 instanceof globals.Headers;\n\tconst source = new globals.Headers(source2 || {});\n\n\tfor (const [key, value] of source) {\n\t\tif ((isHeadersInstance && value === 'undefined') || value === undefined) {\n\t\t\tresult.delete(key);\n\t\t} else {\n\t\t\tresult.set(key, value);\n\t\t}\n\t}\n\n\treturn result;\n};\n\nconst deepMerge = (...sources) => {\n\tlet returnValue = {};\n\tlet headers = {};\n\n\tfor (const source of sources) {\n\t\tif (Array.isArray(source)) {\n\t\t\tif (!(Array.isArray(returnValue))) {\n\t\t\t\treturnValue = [];\n\t\t\t}\n\n\t\t\treturnValue = [...returnValue, ...source];\n\t\t} else if (isObject(source)) {\n\t\t\tfor (let [key, value] of Object.entries(source)) {\n\t\t\t\tif (isObject(value) && Reflect.has(returnValue, key)) {\n\t\t\t\t\tvalue = deepMerge(returnValue[key], value);\n\t\t\t\t}\n\n\t\t\t\treturnValue = {...returnValue, [key]: value};\n\t\t\t}\n\n\t\t\tif (isObject(source.headers)) {\n\t\t\t\theaders = mergeHeaders(headers, source.headers);\n\t\t\t}\n\t\t}\n\n\t\treturnValue.headers = headers;\n\t}\n\n\treturn returnValue;\n};\n\nconst requestMethods = [\n\t'get',\n\t'post',\n\t'put',\n\t'patch',\n\t'head',\n\t'delete'\n];\n\nconst responseTypes = {\n\tjson: 'application/json',\n\ttext: 'text/*',\n\tformData: 'multipart/form-data',\n\tarrayBuffer: '*/*',\n\tblob: '*/*'\n};\n\nconst retryMethods = [\n\t'get',\n\t'put',\n\t'head',\n\t'delete',\n\t'options',\n\t'trace'\n];\n\nconst retryStatusCodes = [\n\t408,\n\t413,\n\t429,\n\t500,\n\t502,\n\t503,\n\t504\n];\n\nconst retryAfterStatusCodes = [\n\t413,\n\t429,\n\t503\n];\n\nconst stop = Symbol('stop');\n\nclass HTTPError extends Error {\n\tconstructor(response) {\n\t\t// Set the message to the status text, such as Unauthorized,\n\t\t// with some fallbacks. This message should never be undefined.\n\t\tsuper(\n\t\t\tresponse.statusText ||\n\t\t\tString(\n\t\t\t\t(response.status === 0 || response.status) ?\n\t\t\t\t\tresponse.status : 'Unknown response error'\n\t\t\t)\n\t\t);\n\t\tthis.name = 'HTTPError';\n\t\tthis.response = response;\n\t}\n}\n\nclass TimeoutError extends Error {\n\tconstructor(request) {\n\t\tsuper('Request timed out');\n\t\tthis.name = 'TimeoutError';\n\t\tthis.request = request;\n\t}\n}\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// `Promise.race()` workaround (#91)\nconst timeout = (request, abortController, options) =>\n\tnew Promise((resolve, reject) => {\n\t\tconst timeoutID = setTimeout(() => {\n\t\t\tif (abortController) {\n\t\t\t\tabortController.abort();\n\t\t\t}\n\n\t\t\treject(new TimeoutError(request));\n\t\t}, options.timeout);\n\n\t\t/* eslint-disable promise/prefer-await-to-then */\n\t\toptions.fetch(request)\n\t\t\t.then(resolve)\n\t\t\t.catch(reject)\n\t\t\t.then(() => {\n\t\t\t\tclearTimeout(timeoutID);\n\t\t\t});\n\t\t/* eslint-enable promise/prefer-await-to-then */\n\t});\n\nconst normalizeRequestMethod = input => requestMethods.includes(input) ? input.toUpperCase() : input;\n\nconst defaultRetryOptions = {\n\tlimit: 2,\n\tmethods: retryMethods,\n\tstatusCodes: retryStatusCodes,\n\tafterStatusCodes: retryAfterStatusCodes\n};\n\nconst normalizeRetryOptions = (retry = {}) => {\n\tif (typeof retry === 'number') {\n\t\treturn {\n\t\t\t...defaultRetryOptions,\n\t\t\tlimit: retry\n\t\t};\n\t}\n\n\tif (retry.methods && !Array.isArray(retry.methods)) {\n\t\tthrow new Error('retry.methods must be an array');\n\t}\n\n\tif (retry.statusCodes && !Array.isArray(retry.statusCodes)) {\n\t\tthrow new Error('retry.statusCodes must be an array');\n\t}\n\n\treturn {\n\t\t...defaultRetryOptions,\n\t\t...retry,\n\t\tafterStatusCodes: retryAfterStatusCodes\n\t};\n};\n\n// The maximum value of a 32bit int (see issue #117)\nconst maxSafeTimeout = 2147483647;\n\nclass Ky {\n\tconstructor(input, options = {}) {\n\t\tthis._retryCount = 0;\n\t\tthis._input = input;\n\t\tthis._options = {\n\t\t\t// TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208\n\t\t\tcredentials: this._input.credentials || 'same-origin',\n\t\t\t...options,\n\t\t\theaders: mergeHeaders(this._input.headers, options.headers),\n\t\t\thooks: deepMerge({\n\t\t\t\tbeforeRequest: [],\n\t\t\t\tbeforeRetry: [],\n\t\t\t\tafterResponse: []\n\t\t\t}, options.hooks),\n\t\t\tmethod: normalizeRequestMethod(options.method || this._input.method),\n\t\t\tprefixUrl: String(options.prefixUrl || ''),\n\t\t\tretry: normalizeRetryOptions(options.retry),\n\t\t\tthrowHttpErrors: options.throwHttpErrors !== false,\n\t\t\ttimeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,\n\t\t\tfetch: options.fetch || globals.fetch\n\t\t};\n\n\t\tif (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globals.Request)) {\n\t\t\tthrow new TypeError('`input` must be a string, URL, or Request');\n\t\t}\n\n\t\tif (this._options.prefixUrl && typeof this._input === 'string') {\n\t\t\tif (this._input.startsWith('/')) {\n\t\t\t\tthrow new Error('`input` must not begin with a slash when using `prefixUrl`');\n\t\t\t}\n\n\t\t\tif (!this._options.prefixUrl.endsWith('/')) {\n\t\t\t\tthis._options.prefixUrl += '/';\n\t\t\t}\n\n\t\t\tthis._input = this._options.prefixUrl + this._input;\n\t\t}\n\n\t\tif (supportsAbortController) {\n\t\t\tthis.abortController = new globals.AbortController();\n\t\t\tif (this._options.signal) {\n\t\t\t\tthis._options.signal.addEventListener('abort', () => {\n\t\t\t\t\tthis.abortController.abort();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._options.signal = this.abortController.signal;\n\t\t}\n\n\t\tthis.request = new globals.Request(this._input, this._options);\n\n\t\tif (this._options.searchParams) {\n\t\t\tconst searchParams = '?' + new URLSearchParams(this._options.searchParams).toString();\n\t\t\tconst url = this.request.url.replace(/(?:\\?.*?)?(?=#|$)/, searchParams);\n\n\t\t\t// To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one\n\t\t\tif (((supportsFormData && this._options.body instanceof globals.FormData) || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {\n\t\t\t\tthis.request.headers.delete('content-type');\n\t\t\t}\n\n\t\t\tthis.request = new globals.Request(new globals.Request(url, this.request), this._options);\n\t\t}\n\n\t\tif (this._options.json !== undefined) {\n\t\t\tthis._options.body = JSON.stringify(this._options.json);\n\t\t\tthis.request.headers.set('content-type', 'application/json');\n\t\t\tthis.request = new globals.Request(this.request, {body: this._options.body});\n\t\t}\n\n\t\tconst fn = async () => {\n\t\t\tif (this._options.timeout > maxSafeTimeout) {\n\t\t\t\tthrow new RangeError(`The \\`timeout\\` option cannot be greater than ${maxSafeTimeout}`);\n\t\t\t}\n\n\t\t\tawait delay(1);\n\t\t\tlet response = await this._fetch();\n\n\t\t\tfor (const hook of this._options.hooks.afterResponse) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tconst modifiedResponse = await hook(\n\t\t\t\t\tthis.request,\n\t\t\t\t\tthis._options,\n\t\t\t\t\tresponse.clone()\n\t\t\t\t);\n\n\t\t\t\tif (modifiedResponse instanceof globals.Response) {\n\t\t\t\t\tresponse = modifiedResponse;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!response.ok && this._options.throwHttpErrors) {\n\t\t\t\tthrow new HTTPError(response);\n\t\t\t}\n\n\t\t\t// If `onDownloadProgress` is passed, it uses the stream API internally\n\t\t\t/* istanbul ignore next */\n\t\t\tif (this._options.onDownloadProgress) {\n\t\t\t\tif (typeof this._options.onDownloadProgress !== 'function') {\n\t\t\t\t\tthrow new TypeError('The `onDownloadProgress` option must be a function');\n\t\t\t\t}\n\n\t\t\t\tif (!supportsStreams) {\n\t\t\t\t\tthrow new Error('Streams are not supported in your environment. `ReadableStream` is missing.');\n\t\t\t\t}\n\n\t\t\t\treturn this._stream(response.clone(), this._options.onDownloadProgress);\n\t\t\t}\n\n\t\t\tif (this._options.parseJson) {\n\t\t\t\tresponse.json = async () => {\n\t\t\t\t\treturn this._options.parseJson(await response.text());\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn response;\n\t\t};\n\n\t\tconst isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());\n\t\tconst result = isRetriableMethod ? this._retry(fn) : fn();\n\n\t\tfor (const [type, mimeType] of Object.entries(responseTypes)) {\n\t\t\tresult[type] = async () => {\n\t\t\t\tthis.request.headers.set('accept', this.request.headers.get('accept') || mimeType);\n\n\t\t\t\tconst response = (await result).clone();\n\n\t\t\t\tif (type === 'json') {\n\t\t\t\t\tif (response.status === 204) {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (options.parseJson) {\n\t\t\t\t\t\treturn options.parseJson(await response.text());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn response[type]();\n\t\t\t};\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_calculateRetryDelay(error) {\n\t\tthis._retryCount++;\n\n\t\tif (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {\n\t\t\tif (error instanceof HTTPError) {\n\t\t\t\tif (!this._options.retry.statusCodes.includes(error.response.status)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tconst retryAfter = error.response.headers.get('Retry-After');\n\t\t\t\tif (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {\n\t\t\t\t\tlet after = Number(retryAfter);\n\t\t\t\t\tif (Number.isNaN(after)) {\n\t\t\t\t\t\tafter = Date.parse(retryAfter) - Date.now();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tafter *= 1000;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn after;\n\t\t\t\t}\n\n\t\t\t\tif (error.response.status === 413) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst BACKOFF_FACTOR = 0.3;\n\t\t\treturn BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tasync _retry(fn) {\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} catch (error) {\n\t\t\tconst ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);\n\t\t\tif (ms !== 0 && this._retryCount > 0) {\n\t\t\t\tawait delay(ms);\n\n\t\t\t\tfor (const hook of this._options.hooks.beforeRetry) {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tconst hookResult = await hook({\n\t\t\t\t\t\trequest: this.request,\n\t\t\t\t\t\toptions: this._options,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tresponse: error.response.clone(),\n\t\t\t\t\t\tretryCount: this._retryCount\n\t\t\t\t\t});\n\n\t\t\t\t\t// If `stop` is returned from the hook, the retry process is stopped\n\t\t\t\t\tif (hookResult === stop) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this._retry(fn);\n\t\t\t}\n\n\t\t\tif (this._options.throwHttpErrors) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _fetch() {\n\t\tfor (const hook of this._options.hooks.beforeRequest) {\n\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\tconst result = await hook(this.request, this._options);\n\n\t\t\tif (result instanceof Request) {\n\t\t\t\tthis.request = result;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (result instanceof Response) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tif (this._options.timeout === false) {\n\t\t\treturn this._options.fetch(this.request.clone());\n\t\t}\n\n\t\treturn timeout(this.request.clone(), this.abortController, this._options);\n\t}\n\n\t/* istanbul ignore next */\n\t_stream(response, onDownloadProgress) {\n\t\tconst totalBytes = Number(response.headers.get('content-length')) || 0;\n\t\tlet transferredBytes = 0;\n\n\t\treturn new globals.Response(\n\t\t\tnew globals.ReadableStream({\n\t\t\t\tstart(controller) {\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\tif (onDownloadProgress) {\n\t\t\t\t\t\tonDownloadProgress({percent: 0, transferredBytes: 0, totalBytes}, new Uint8Array());\n\t\t\t\t\t}\n\n\t\t\t\t\tasync function read() {\n\t\t\t\t\t\tconst {done, value} = await reader.read();\n\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (onDownloadProgress) {\n\t\t\t\t\t\t\ttransferredBytes += value.byteLength;\n\t\t\t\t\t\t\tconst percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;\n\t\t\t\t\t\t\tonDownloadProgress({percent, transferredBytes, totalBytes}, value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontroller.enqueue(value);\n\t\t\t\t\t\tread();\n\t\t\t\t\t}\n\n\t\t\t\t\tread();\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}\n\nconst validateAndMerge = (...sources) => {\n\tfor (const source of sources) {\n\t\tif ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n\t\t\tthrow new TypeError('The `options` argument must be an object');\n\t\t}\n\t}\n\n\treturn deepMerge({}, ...sources);\n};\n\nconst createInstance = defaults => {\n\tconst ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));\n\n\tfor (const method of requestMethods) {\n\t\tky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, {method}));\n\t}\n\n\tky.HTTPError = HTTPError;\n\tky.TimeoutError = TimeoutError;\n\tky.create = newDefaults => createInstance(validateAndMerge(newDefaults));\n\tky.extend = newDefaults => createInstance(validateAndMerge(defaults, newDefaults));\n\tky.stop = stop;\n\n\treturn ky;\n};\n\nexport default createInstance();\n"]},"metadata":{},"sourceType":"module"}