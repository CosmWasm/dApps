{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Secp256k1Wallet = exports.extractKdfConfiguration = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst address_1 = require(\"./address\");\n\nconst signature_1 = require(\"./signature\");\n\nconst wallet_1 = require(\"./wallet\");\n\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 12.15 and should have similar runtimes in other modern Wasm hosts.\n */\n\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 20,\n    memLimitKib: 12 * 1024\n  }\n};\n\nfunction isSecp256k1DerivationJson(thing) {\n  if (!utils_1.isNonNullObject(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\n\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\n\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\n\nexports.extractKdfConfiguration = extractKdfConfiguration;\n\nclass Secp256k1Wallet {\n  constructor(mnemonic, hdPath, privkey, pubkey, prefix) {\n    this.secret = mnemonic;\n    this.accounts = [{\n      hdPath: hdPath,\n      prefix: prefix\n    }];\n    this.privkey = privkey;\n    this.pubkey = pubkey;\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param hdPath The BIP-32/SLIP-10 derivation path. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`.\n   * @param prefix The bech32 address prefix (human readable part). Defaults to \"cosmos\".\n   */\n\n\n  static async fromMnemonic(mnemonic, hdPath = wallet_1.makeCosmoshubPath(0), prefix = \"cosmos\") {\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked);\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, seed, hdPath);\n    const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;\n    return new Secp256k1Wallet(mnemonicChecked, hdPath, privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param hdPath The BIP-32/SLIP-10 derivation path. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`.\n   * @param prefix The bech32 address prefix (human readable part). Defaults to \"cosmos\".\n   */\n\n\n  static async generate(length = 12, hdPath = wallet_1.makeCosmoshubPath(0), prefix = \"cosmos\") {\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return Secp256k1Wallet.fromMnemonic(mnemonic.toString(), hdPath, prefix);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n    switch (root.type) {\n      case serializationTypeV1:\n        return Secp256k1Wallet.deserializeTypeV1(serialization, password);\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n\n\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          utils_1.assert(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n          if (accounts.length !== 1) throw new Error(\"Property 'accounts' only supports one entry\");\n          const account = accounts[0];\n          if (!isSecp256k1DerivationJson(account)) throw new Error(\"Account is not in the correct format.\");\n          return Secp256k1Wallet.fromMnemonic(mnemonic, crypto_1.stringToPath(account.hdPath), account.prefix);\n        }\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await wallet_1.executeKdf(password, root.kdf);\n    return Secp256k1Wallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n\n  get mnemonic() {\n    return this.secret.toString();\n  }\n\n  get address() {\n    return address_1.rawSecp256k1PubkeyToAddress(this.pubkey, this.accounts[0].prefix);\n  }\n\n  async getAccounts() {\n    return [{\n      algo: \"secp256k1\",\n      address: this.address,\n      pubkey: this.pubkey\n    }];\n  }\n\n  async sign(address, message, prehashType = \"sha256\") {\n    if (address !== this.address) {\n      throw new Error(`Address ${address} not found in wallet`);\n    }\n\n    const hashedMessage = wallet_1.prehash(message, prehashType);\n    const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    return signature_1.encodeSecp256k1Signature(this.pubkey, signatureBytes);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await wallet_1.executeKdf(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n\n\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(account => ({\n        hdPath: crypto_1.pathToString(account.hdPath),\n        prefix: account.prefix\n      }))\n    };\n    const dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: encoding_1.toBase64(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n\n}\n\nexports.Secp256k1Wallet = Secp256k1Wallet;","map":{"version":3,"sources":["../src/secp256k1wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Secp256k1Wallet = exports.extractKdfConfiguration = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst address_1 = require(\"./address\");\nconst signature_1 = require(\"./signature\");\nconst wallet_1 = require(\"./wallet\");\nconst serializationTypeV1 = \"secp256k1wallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 12.15 and should have similar runtimes in other modern Wasm hosts.\n */\nconst basicPasswordHashingOptions = {\n    algorithm: \"argon2id\",\n    params: {\n        outputLength: 32,\n        opsLimit: 20,\n        memLimitKib: 12 * 1024,\n    },\n};\nfunction isSecp256k1DerivationJson(thing) {\n    if (!utils_1.isNonNullObject(thing))\n        return false;\n    if (typeof thing.hdPath !== \"string\")\n        return false;\n    if (typeof thing.prefix !== \"string\")\n        return false;\n    return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n    return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n    const root = JSON.parse(serialization);\n    if (!utils_1.isNonNullObject(root))\n        throw new Error(\"Root document is not an object.\");\n    switch (root.type) {\n        case serializationTypeV1:\n            return extractKdfConfigurationV1(root);\n        default:\n            throw new Error(\"Unsupported serialization type\");\n    }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nclass Secp256k1Wallet {\n    constructor(mnemonic, hdPath, privkey, pubkey, prefix) {\n        this.secret = mnemonic;\n        this.accounts = [\n            {\n                hdPath: hdPath,\n                prefix: prefix,\n            },\n        ];\n        this.privkey = privkey;\n        this.pubkey = pubkey;\n    }\n    /**\n     * Restores a wallet from the given BIP39 mnemonic.\n     *\n     * @param mnemonic Any valid English mnemonic.\n     * @param hdPath The BIP-32/SLIP-10 derivation path. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`.\n     * @param prefix The bech32 address prefix (human readable part). Defaults to \"cosmos\".\n     */\n    static async fromMnemonic(mnemonic, hdPath = wallet_1.makeCosmoshubPath(0), prefix = \"cosmos\") {\n        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked);\n        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, seed, hdPath);\n        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;\n        return new Secp256k1Wallet(mnemonicChecked, hdPath, privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);\n    }\n    /**\n     * Generates a new wallet with a BIP39 mnemonic of the given length.\n     *\n     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n     * @param hdPath The BIP-32/SLIP-10 derivation path. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`.\n     * @param prefix The bech32 address prefix (human readable part). Defaults to \"cosmos\".\n     */\n    static async generate(length = 12, hdPath = wallet_1.makeCosmoshubPath(0), prefix = \"cosmos\") {\n        const entropyLength = 4 * Math.floor((11 * length) / 33);\n        const entropy = crypto_1.Random.getBytes(entropyLength);\n        const mnemonic = crypto_1.Bip39.encode(entropy);\n        return Secp256k1Wallet.fromMnemonic(mnemonic.toString(), hdPath, prefix);\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    static async deserialize(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!utils_1.isNonNullObject(root))\n            throw new Error(\"Root document is not an object.\");\n        switch (root.type) {\n            case serializationTypeV1:\n                return Secp256k1Wallet.deserializeTypeV1(serialization, password);\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n     */\n    static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n        const root = JSON.parse(serialization);\n        if (!utils_1.isNonNullObject(root))\n            throw new Error(\"Root document is not an object.\");\n        const untypedRoot = root;\n        switch (untypedRoot.type) {\n            case serializationTypeV1: {\n                const decryptedBytes = await wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n                const decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n                const { mnemonic, accounts } = decryptedDocument;\n                utils_1.assert(typeof mnemonic === \"string\");\n                if (!Array.isArray(accounts))\n                    throw new Error(\"Property 'accounts' is not an array\");\n                if (accounts.length !== 1)\n                    throw new Error(\"Property 'accounts' only supports one entry\");\n                const account = accounts[0];\n                if (!isSecp256k1DerivationJson(account))\n                    throw new Error(\"Account is not in the correct format.\");\n                return Secp256k1Wallet.fromMnemonic(mnemonic, crypto_1.stringToPath(account.hdPath), account.prefix);\n            }\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    static async deserializeTypeV1(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!utils_1.isNonNullObject(root))\n            throw new Error(\"Root document is not an object.\");\n        const encryptionKey = await wallet_1.executeKdf(password, root.kdf);\n        return Secp256k1Wallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n    }\n    get mnemonic() {\n        return this.secret.toString();\n    }\n    get address() {\n        return address_1.rawSecp256k1PubkeyToAddress(this.pubkey, this.accounts[0].prefix);\n    }\n    async getAccounts() {\n        return [\n            {\n                algo: \"secp256k1\",\n                address: this.address,\n                pubkey: this.pubkey,\n            },\n        ];\n    }\n    async sign(address, message, prehashType = \"sha256\") {\n        if (address !== this.address) {\n            throw new Error(`Address ${address} not found in wallet`);\n        }\n        const hashedMessage = wallet_1.prehash(message, prehashType);\n        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);\n        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n        return signature_1.encodeSecp256k1Signature(this.pubkey, signatureBytes);\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    async serialize(password) {\n        const kdfConfiguration = basicPasswordHashingOptions;\n        const encryptionKey = await wallet_1.executeKdf(password, kdfConfiguration);\n        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n     * is not the case, the wallet cannot be restored with the original password.\n     */\n    async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n        const dataToEncrypt = {\n            mnemonic: this.mnemonic,\n            accounts: this.accounts.map((account) => ({\n                hdPath: crypto_1.pathToString(account.hdPath),\n                prefix: account.prefix,\n            })),\n        };\n        const dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n        const encryptionConfiguration = {\n            algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf,\n        };\n        const encryptedData = await wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n        const out = {\n            type: serializationTypeV1,\n            kdf: kdfConfiguration,\n            encryption: encryptionConfiguration,\n            data: encoding_1.toBase64(encryptedData),\n        };\n        return JSON.stringify(out);\n    }\n}\nexports.Secp256k1Wallet = Secp256k1Wallet;\n//# sourceMappingURL=secp256k1wallet.js.map"]},"metadata":{},"sourceType":"script"}