{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAttribute = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nfunction parseAttribute(input) {\n  if (!utils_1.isNonNullObject(input)) throw new Error(\"Attribute must be a non-null object\");\n  const {\n    key,\n    value\n  } = input;\n  if (typeof key !== \"string\" || !key) throw new Error(\"Attribute's key must be a non-empty string\");\n\n  if (typeof value !== \"string\" && typeof value !== \"undefined\") {\n    throw new Error(\"Attribute's value must be a string or unset\");\n  }\n\n  return {\n    key: key,\n    value: value || \"\"\n  };\n}\n\nexports.parseAttribute = parseAttribute;\n\nfunction parseEvent(input) {\n  if (!utils_1.isNonNullObject(input)) throw new Error(\"Event must be a non-null object\");\n  const {\n    type,\n    attributes\n  } = input;\n\n  if (typeof type !== \"string\" || type === \"\") {\n    throw new Error(`Event type must be a non-empty string`);\n  }\n\n  if (!Array.isArray(attributes)) throw new Error(\"Event's attributes must be an array\");\n  return {\n    type: type,\n    attributes: attributes.map(parseAttribute)\n  };\n}\n\nexports.parseEvent = parseEvent;\n\nfunction parseLog(input) {\n  if (!utils_1.isNonNullObject(input)) throw new Error(\"Log must be a non-null object\");\n  const {\n    msg_index,\n    log,\n    events\n  } = input;\n  if (typeof msg_index !== \"number\") throw new Error(\"Log's msg_index must be a number\");\n  if (typeof log !== \"string\") throw new Error(\"Log's log must be a string\");\n  if (!Array.isArray(events)) throw new Error(\"Log's events must be an array\");\n  return {\n    msg_index: msg_index,\n    log: log,\n    events: events.map(parseEvent)\n  };\n}\n\nexports.parseLog = parseLog;\n\nfunction parseLogs(input) {\n  if (!Array.isArray(input)) throw new Error(\"Logs must be an array\");\n  return input.map(parseLog);\n}\n\nexports.parseLogs = parseLogs;\n/**\n * Searches in logs for the first event of the given event type and in that event\n * for the first first attribute with the given attribute key.\n *\n * Throws if the attribute was not found.\n */\n\nfunction findAttribute(logs, eventType, attrKey) {\n  var _a;\n\n  const firstLogs = logs.find(() => true);\n  const out = (_a = firstLogs === null || firstLogs === void 0 ? void 0 : firstLogs.events.find(event => event.type === eventType)) === null || _a === void 0 ? void 0 : _a.attributes.find(attr => attr.key === attrKey);\n\n  if (!out) {\n    throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);\n  }\n\n  return out;\n}\n\nexports.findAttribute = findAttribute;","map":{"version":3,"sources":["../src/logs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findAttribute = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction parseAttribute(input) {\n    if (!utils_1.isNonNullObject(input))\n        throw new Error(\"Attribute must be a non-null object\");\n    const { key, value } = input;\n    if (typeof key !== \"string\" || !key)\n        throw new Error(\"Attribute's key must be a non-empty string\");\n    if (typeof value !== \"string\" && typeof value !== \"undefined\") {\n        throw new Error(\"Attribute's value must be a string or unset\");\n    }\n    return {\n        key: key,\n        value: value || \"\",\n    };\n}\nexports.parseAttribute = parseAttribute;\nfunction parseEvent(input) {\n    if (!utils_1.isNonNullObject(input))\n        throw new Error(\"Event must be a non-null object\");\n    const { type, attributes } = input;\n    if (typeof type !== \"string\" || type === \"\") {\n        throw new Error(`Event type must be a non-empty string`);\n    }\n    if (!Array.isArray(attributes))\n        throw new Error(\"Event's attributes must be an array\");\n    return {\n        type: type,\n        attributes: attributes.map(parseAttribute),\n    };\n}\nexports.parseEvent = parseEvent;\nfunction parseLog(input) {\n    if (!utils_1.isNonNullObject(input))\n        throw new Error(\"Log must be a non-null object\");\n    const { msg_index, log, events } = input;\n    if (typeof msg_index !== \"number\")\n        throw new Error(\"Log's msg_index must be a number\");\n    if (typeof log !== \"string\")\n        throw new Error(\"Log's log must be a string\");\n    if (!Array.isArray(events))\n        throw new Error(\"Log's events must be an array\");\n    return {\n        msg_index: msg_index,\n        log: log,\n        events: events.map(parseEvent),\n    };\n}\nexports.parseLog = parseLog;\nfunction parseLogs(input) {\n    if (!Array.isArray(input))\n        throw new Error(\"Logs must be an array\");\n    return input.map(parseLog);\n}\nexports.parseLogs = parseLogs;\n/**\n * Searches in logs for the first event of the given event type and in that event\n * for the first first attribute with the given attribute key.\n *\n * Throws if the attribute was not found.\n */\nfunction findAttribute(logs, eventType, attrKey) {\n    var _a;\n    const firstLogs = logs.find(() => true);\n    const out = (_a = firstLogs === null || firstLogs === void 0 ? void 0 : firstLogs.events.find((event) => event.type === eventType)) === null || _a === void 0 ? void 0 : _a.attributes.find((attr) => attr.key === attrKey);\n    if (!out) {\n        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);\n    }\n    return out;\n}\nexports.findAttribute = findAttribute;\n//# sourceMappingURL=logs.js.map"]},"metadata":{},"sourceType":"script"}