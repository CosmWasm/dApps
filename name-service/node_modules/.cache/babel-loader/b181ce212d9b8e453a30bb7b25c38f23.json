{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;\n\nfunction trimLeadingNullBytes(inData) {\n  let numberOfLeadingNullBytes = 0;\n\n  for (const byte of inData) {\n    if (byte === 0x00) {\n      numberOfLeadingNullBytes++;\n    } else {\n      break;\n    }\n  }\n\n  return inData.slice(numberOfLeadingNullBytes);\n}\n\nconst derTagInteger = 0x02;\n\nclass Secp256k1Signature {\n  constructor(r, s) {\n    if (r.length > 32 || r.length === 0 || r[0] === 0x00) {\n      throw new Error(\"Unsigned integer r must be encoded as unpadded big endian.\");\n    }\n\n    if (s.length > 32 || s.length === 0 || s[0] === 0x00) {\n      throw new Error(\"Unsigned integer s must be encoded as unpadded big endian.\");\n    }\n\n    this.data = {\n      r: r,\n      s: s\n    };\n  }\n  /**\n   * Takes the pair of integers (r, s) as 2x32 byte of binary data.\n   *\n   * Note: This is the format Cosmos SDK uses natively.\n   *\n   * @param data a 64 byte value containing integers r and s.\n   */\n\n\n  static fromFixedLength(data) {\n    if (data.length !== 64) {\n      throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);\n    }\n\n    return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));\n  }\n\n  static fromDer(data) {\n    let pos = 0;\n\n    if (data[pos++] !== 0x30) {\n      throw new Error(\"Prefix 0x30 expected\");\n    }\n\n    const bodyLength = data[pos++];\n\n    if (data.length - pos !== bodyLength) {\n      throw new Error(\"Data length mismatch detected\");\n    } // r\n\n\n    const rTag = data[pos++];\n\n    if (rTag !== derTagInteger) {\n      throw new Error(\"INTEGER tag expected\");\n    }\n\n    const rLength = data[pos++];\n\n    if (rLength >= 0x80) {\n      throw new Error(\"Decoding length values above 127 not supported\");\n    }\n\n    const rData = data.slice(pos, pos + rLength);\n    pos += rLength; // s\n\n    const sTag = data[pos++];\n\n    if (sTag !== derTagInteger) {\n      throw new Error(\"INTEGER tag expected\");\n    }\n\n    const sLength = data[pos++];\n\n    if (sLength >= 0x80) {\n      throw new Error(\"Decoding length values above 127 not supported\");\n    }\n\n    const sData = data.slice(pos, pos + sLength);\n    pos += sLength;\n    return new Secp256k1Signature( // r/s data can contain leading 0 bytes to express integers being non-negative in DER\n    trimLeadingNullBytes(rData), trimLeadingNullBytes(sData));\n  }\n\n  r(length) {\n    if (length === undefined) {\n      return this.data.r;\n    } else {\n      const paddingLength = length - this.data.r.length;\n\n      if (paddingLength < 0) {\n        throw new Error(\"Length too small to hold parameter r\");\n      }\n\n      const padding = new Uint8Array(paddingLength);\n      return new Uint8Array([...padding, ...this.data.r]);\n    }\n  }\n\n  s(length) {\n    if (length === undefined) {\n      return this.data.s;\n    } else {\n      const paddingLength = length - this.data.s.length;\n\n      if (paddingLength < 0) {\n        throw new Error(\"Length too small to hold parameter s\");\n      }\n\n      const padding = new Uint8Array(paddingLength);\n      return new Uint8Array([...padding, ...this.data.s]);\n    }\n  }\n\n  toDer() {\n    // DER supports negative integers but our data is unsigned. Thus we need to prepend\n    // a leading 0 byte when the higest bit is set to differentiate nagative values\n    const rEncoded = this.data.r[0] >= 0x80 ? new Uint8Array([0, ...this.data.r]) : this.data.r;\n    const sEncoded = this.data.s[0] >= 0x80 ? new Uint8Array([0, ...this.data.s]) : this.data.s;\n    const rLength = rEncoded.length;\n    const sLength = sEncoded.length;\n    const data = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);\n    return new Uint8Array([0x30, data.length, ...data]);\n  }\n\n}\n\nexports.Secp256k1Signature = Secp256k1Signature;\n/**\n * A Secp256k1Signature plus the recovery parameter\n */\n\nclass ExtendedSecp256k1Signature extends Secp256k1Signature {\n  constructor(r, s, recovery) {\n    super(r, s);\n\n    if (!Number.isInteger(recovery)) {\n      throw new Error(\"The recovery parameter must be an integer.\");\n    }\n\n    if (recovery < 0 || recovery > 4) {\n      throw new Error(\"The recovery parameter must be one of 0, 1, 2, 3.\");\n    }\n\n    this.recovery = recovery;\n  }\n  /**\n   * Decode extended signature from the simple fixed length encoding\n   * described in toFixedLength().\n   */\n\n\n  static fromFixedLength(data) {\n    if (data.length !== 65) {\n      throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);\n    }\n\n    return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);\n  }\n  /**\n   * A simple custom encoding that encodes the extended signature as\n   * r (32 bytes) | s (32 bytes) | recovery param (1 byte)\n   * where | denotes concatenation of bonary data.\n   */\n\n\n  toFixedLength() {\n    return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);\n  }\n\n}\n\nexports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;","map":{"version":3,"sources":["../src/secp256k1signature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;\nfunction trimLeadingNullBytes(inData) {\n    let numberOfLeadingNullBytes = 0;\n    for (const byte of inData) {\n        if (byte === 0x00) {\n            numberOfLeadingNullBytes++;\n        }\n        else {\n            break;\n        }\n    }\n    return inData.slice(numberOfLeadingNullBytes);\n}\nconst derTagInteger = 0x02;\nclass Secp256k1Signature {\n    constructor(r, s) {\n        if (r.length > 32 || r.length === 0 || r[0] === 0x00) {\n            throw new Error(\"Unsigned integer r must be encoded as unpadded big endian.\");\n        }\n        if (s.length > 32 || s.length === 0 || s[0] === 0x00) {\n            throw new Error(\"Unsigned integer s must be encoded as unpadded big endian.\");\n        }\n        this.data = {\n            r: r,\n            s: s,\n        };\n    }\n    /**\n     * Takes the pair of integers (r, s) as 2x32 byte of binary data.\n     *\n     * Note: This is the format Cosmos SDK uses natively.\n     *\n     * @param data a 64 byte value containing integers r and s.\n     */\n    static fromFixedLength(data) {\n        if (data.length !== 64) {\n            throw new Error(`Got invalid data length: ${data.length}. Expected 2x 32 bytes for the pair (r, s)`);\n        }\n        return new Secp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)));\n    }\n    static fromDer(data) {\n        let pos = 0;\n        if (data[pos++] !== 0x30) {\n            throw new Error(\"Prefix 0x30 expected\");\n        }\n        const bodyLength = data[pos++];\n        if (data.length - pos !== bodyLength) {\n            throw new Error(\"Data length mismatch detected\");\n        }\n        // r\n        const rTag = data[pos++];\n        if (rTag !== derTagInteger) {\n            throw new Error(\"INTEGER tag expected\");\n        }\n        const rLength = data[pos++];\n        if (rLength >= 0x80) {\n            throw new Error(\"Decoding length values above 127 not supported\");\n        }\n        const rData = data.slice(pos, pos + rLength);\n        pos += rLength;\n        // s\n        const sTag = data[pos++];\n        if (sTag !== derTagInteger) {\n            throw new Error(\"INTEGER tag expected\");\n        }\n        const sLength = data[pos++];\n        if (sLength >= 0x80) {\n            throw new Error(\"Decoding length values above 127 not supported\");\n        }\n        const sData = data.slice(pos, pos + sLength);\n        pos += sLength;\n        return new Secp256k1Signature(\n        // r/s data can contain leading 0 bytes to express integers being non-negative in DER\n        trimLeadingNullBytes(rData), trimLeadingNullBytes(sData));\n    }\n    r(length) {\n        if (length === undefined) {\n            return this.data.r;\n        }\n        else {\n            const paddingLength = length - this.data.r.length;\n            if (paddingLength < 0) {\n                throw new Error(\"Length too small to hold parameter r\");\n            }\n            const padding = new Uint8Array(paddingLength);\n            return new Uint8Array([...padding, ...this.data.r]);\n        }\n    }\n    s(length) {\n        if (length === undefined) {\n            return this.data.s;\n        }\n        else {\n            const paddingLength = length - this.data.s.length;\n            if (paddingLength < 0) {\n                throw new Error(\"Length too small to hold parameter s\");\n            }\n            const padding = new Uint8Array(paddingLength);\n            return new Uint8Array([...padding, ...this.data.s]);\n        }\n    }\n    toDer() {\n        // DER supports negative integers but our data is unsigned. Thus we need to prepend\n        // a leading 0 byte when the higest bit is set to differentiate nagative values\n        const rEncoded = this.data.r[0] >= 0x80 ? new Uint8Array([0, ...this.data.r]) : this.data.r;\n        const sEncoded = this.data.s[0] >= 0x80 ? new Uint8Array([0, ...this.data.s]) : this.data.s;\n        const rLength = rEncoded.length;\n        const sLength = sEncoded.length;\n        const data = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);\n        return new Uint8Array([0x30, data.length, ...data]);\n    }\n}\nexports.Secp256k1Signature = Secp256k1Signature;\n/**\n * A Secp256k1Signature plus the recovery parameter\n */\nclass ExtendedSecp256k1Signature extends Secp256k1Signature {\n    constructor(r, s, recovery) {\n        super(r, s);\n        if (!Number.isInteger(recovery)) {\n            throw new Error(\"The recovery parameter must be an integer.\");\n        }\n        if (recovery < 0 || recovery > 4) {\n            throw new Error(\"The recovery parameter must be one of 0, 1, 2, 3.\");\n        }\n        this.recovery = recovery;\n    }\n    /**\n     * Decode extended signature from the simple fixed length encoding\n     * described in toFixedLength().\n     */\n    static fromFixedLength(data) {\n        if (data.length !== 65) {\n            throw new Error(`Got invalid data length ${data.length}. Expected 32 + 32 + 1`);\n        }\n        return new ExtendedSecp256k1Signature(trimLeadingNullBytes(data.slice(0, 32)), trimLeadingNullBytes(data.slice(32, 64)), data[64]);\n    }\n    /**\n     * A simple custom encoding that encodes the extended signature as\n     * r (32 bytes) | s (32 bytes) | recovery param (1 byte)\n     * where | denotes concatenation of bonary data.\n     */\n    toFixedLength() {\n        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);\n    }\n}\nexports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature;\n//# sourceMappingURL=secp256k1signature.js.map"]},"metadata":{},"sourceType":"script"}