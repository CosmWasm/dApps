{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmWasmClient = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst launchpad_1 = require(\"@cosmjs/launchpad\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nconst wasm_1 = require(\"./lcdapi/wasm\");\n\nconst logs_1 = require(\"./logs\");\n\nfunction isSearchByIdQuery(query) {\n  return query.id !== undefined;\n}\n\nfunction isSearchByHeightQuery(query) {\n  return query.height !== undefined;\n}\n\nfunction isSearchBySentFromOrToQuery(query) {\n  return query.sentFromOrTo !== undefined;\n}\n\nfunction isSearchByTagsQuery(query) {\n  return query.tags !== undefined;\n}\n\nclass CosmWasmClient {\n  /**\n   * Creates a new client to interact with a CosmWasm blockchain.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  constructor(apiUrl, broadcastMode = launchpad_1.BroadcastMode.Block) {\n    this.codesCache = new Map();\n    this.lcdClient = launchpad_1.LcdClient.withExtensions({\n      apiUrl: apiUrl,\n      broadcastMode: broadcastMode\n    }, launchpad_1.setupAuthExtension, wasm_1.setupWasmExtension);\n  }\n\n  async getChainId() {\n    if (!this.chainId) {\n      const response = await this.lcdClient.nodeInfo();\n      const chainId = response.node_info.network;\n      if (!chainId) throw new Error(\"Chain ID must not be empty\");\n      this.chainId = chainId;\n    }\n\n    return this.chainId;\n  }\n\n  async getHeight() {\n    if (this.anyValidAddress) {\n      const {\n        height\n      } = await this.lcdClient.auth.account(this.anyValidAddress);\n      return parseInt(height, 10);\n    } else {\n      // Note: this gets inefficient when blocks contain a lot of transactions since it\n      // requires downloading and deserializing all transactions in the block.\n      const latest = await this.lcdClient.blocksLatest();\n      return parseInt(latest.block.header.height, 10);\n    }\n  }\n  /**\n   * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n   */\n\n\n  async getIdentifier(tx) {\n    // We consult the REST API because we don't have a local amino encoder\n    const response = await this.lcdClient.encodeTx(tx);\n    const hash = new crypto_1.Sha256(encoding_1.fromBase64(response.tx)).digest();\n    return encoding_1.toHex(hash).toUpperCase();\n  }\n  /**\n   * Returns account number and sequence.\n   *\n   * Throws if the account does not exist on chain.\n   *\n   * @param address returns data for this address. When unset, the client's sender adddress is used.\n   */\n\n\n  async getSequence(address) {\n    const account = await this.getAccount(address);\n\n    if (!account) {\n      throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n    }\n\n    return {\n      accountNumber: account.accountNumber,\n      sequence: account.sequence\n    };\n  }\n\n  async getAccount(address) {\n    const account = await this.lcdClient.auth.account(address);\n    const value = account.result.value;\n\n    if (value.address === \"\") {\n      return undefined;\n    } else {\n      this.anyValidAddress = value.address;\n      return {\n        address: value.address,\n        balance: value.coins,\n        pubkey: launchpad_1.normalizePubkey(value.public_key) || undefined,\n        accountNumber: launchpad_1.uint64ToNumber(value.account_number),\n        sequence: launchpad_1.uint64ToNumber(value.sequence)\n      };\n    }\n  }\n  /**\n   * Gets block header and meta\n   *\n   * @param height The height of the block. If undefined, the latest height is used.\n   */\n\n\n  async getBlock(height) {\n    const response = height !== undefined ? await this.lcdClient.blocks(height) : await this.lcdClient.blocksLatest();\n    return {\n      id: response.block_id.hash,\n      header: {\n        version: response.block.header.version,\n        time: response.block.header.time,\n        height: parseInt(response.block.header.height, 10),\n        chainId: response.block.header.chain_id\n      },\n      txs: (response.block.data.txs || []).map(encoding_1.fromBase64)\n    };\n  }\n\n  async searchTx(query, filter = {}) {\n    const minHeight = filter.minHeight || 0;\n    const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n    if (maxHeight < minHeight) return []; // optional optimization\n\n    function withFilters(originalQuery) {\n      return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;\n    }\n\n    let txs;\n\n    if (isSearchByIdQuery(query)) {\n      txs = await this.txsQuery(`tx.hash=${query.id}`);\n    } else if (isSearchByHeightQuery(query)) {\n      // optional optimization to avoid network request\n      if (query.height < minHeight || query.height > maxHeight) {\n        txs = [];\n      } else {\n        txs = await this.txsQuery(`tx.height=${query.height}`);\n      }\n    } else if (isSearchBySentFromOrToQuery(query)) {\n      // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n      const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);\n      const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);\n      const [sent, received] = await Promise.all([this.txsQuery(sentQuery), this.txsQuery(receivedQuery)]);\n      let mergedTxs = [];\n      /* eslint-disable @typescript-eslint/no-non-null-assertion */\n      // sent/received are presorted\n\n      while (sent.length && received.length) {\n        const next = sent[0].hash === received[0].hash ? sent.shift() && received.shift() : sent[0].height <= received[0].height ? sent.shift() : received.shift();\n        mergedTxs = [...mergedTxs, next];\n      }\n      /* eslint-enable @typescript-eslint/no-non-null-assertion */\n      // At least one of sent/received is empty by now\n\n\n      txs = [...mergedTxs, ...sent, ...received];\n    } else if (isSearchByTagsQuery(query)) {\n      const rawQuery = withFilters(query.tags.map(t => `${t.key}=${t.value}`).join(\"&\"));\n      txs = await this.txsQuery(rawQuery);\n    } else {\n      throw new Error(\"Unknown query type\");\n    } // backend sometimes messes up with min/max height filtering\n\n\n    const filtered = txs.filter(tx => tx.height >= minHeight && tx.height <= maxHeight);\n    return filtered;\n  }\n\n  async postTx(tx) {\n    const result = await this.lcdClient.postTx(tx);\n\n    if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n      throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n    }\n\n    return result.code !== undefined ? {\n      height: math_1.Uint53.fromString(result.height).toNumber(),\n      transactionHash: result.txhash,\n      code: result.code,\n      rawLog: result.raw_log || \"\"\n    } : {\n      logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n      rawLog: result.raw_log || \"\",\n      transactionHash: result.txhash,\n      data: result.data ? encoding_1.fromHex(result.data) : undefined\n    };\n  }\n\n  async getCodes() {\n    const result = await this.lcdClient.wasm.listCodeInfo();\n    return result.map(entry => {\n      this.anyValidAddress = entry.creator;\n      return {\n        id: entry.id,\n        creator: entry.creator,\n        checksum: encoding_1.toHex(encoding_1.fromHex(entry.data_hash)),\n        source: entry.source || undefined,\n        builder: entry.builder || undefined\n      };\n    });\n  }\n\n  async getCodeDetails(codeId) {\n    const cached = this.codesCache.get(codeId);\n    if (cached) return cached;\n    const getCodeResult = await this.lcdClient.wasm.getCode(codeId);\n    const codeDetails = {\n      id: getCodeResult.id,\n      creator: getCodeResult.creator,\n      checksum: encoding_1.toHex(encoding_1.fromHex(getCodeResult.data_hash)),\n      source: getCodeResult.source || undefined,\n      builder: getCodeResult.builder || undefined,\n      data: encoding_1.fromBase64(getCodeResult.data)\n    };\n    this.codesCache.set(codeId, codeDetails);\n    return codeDetails;\n  }\n\n  async getContracts(codeId) {\n    const result = await this.lcdClient.wasm.listContractsByCodeId(codeId);\n    return result.map(entry => ({\n      address: entry.address,\n      codeId: entry.code_id,\n      creator: entry.creator,\n      admin: entry.admin,\n      label: entry.label\n    }));\n  }\n  /**\n   * Throws an error if no contract was found at the address\n   */\n\n\n  async getContract(address) {\n    const result = await this.lcdClient.wasm.getContractInfo(address);\n    if (!result) throw new Error(`No contract found at address \"${address}\"`);\n    return {\n      address: result.address,\n      codeId: result.code_id,\n      creator: result.creator,\n      admin: result.admin,\n      label: result.label\n    };\n  }\n  /**\n   * Throws an error if no contract was found at the address\n   */\n\n\n  async getContractCodeHistory(address) {\n    const result = await this.lcdClient.wasm.getContractCodeHistory(address);\n    if (!result) throw new Error(`No contract history found for address \"${address}\"`);\n    return result.map(entry => ({\n      operation: entry.operation,\n      codeId: entry.code_id,\n      msg: entry.msg\n    }));\n  }\n  /**\n   * Returns the data at the key if present (raw contract dependent storage data)\n   * or null if no data at this key.\n   *\n   * Promise is rejected when contract does not exist.\n   */\n\n\n  async queryContractRaw(address, key) {\n    // just test contract existence\n    const _info = await this.getContract(address);\n\n    return this.lcdClient.wasm.queryContractRaw(address, key);\n  }\n  /**\n   * Makes a smart query on the contract, returns the parsed JSON document.\n   *\n   * Promise is rejected when contract does not exist.\n   * Promise is rejected for invalid query format.\n   * Promise is rejected for invalid response format.\n   */\n\n\n  async queryContractSmart(address, queryMsg) {\n    try {\n      return await this.lcdClient.wasm.queryContractSmart(address, queryMsg);\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message.startsWith(\"not found: contract\")) {\n          throw new Error(`No contract found at address \"${address}\"`);\n        } else {\n          throw error;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async txsQuery(query) {\n    // TODO: we need proper pagination support\n    const limit = 100;\n    const result = await this.lcdClient.txsQuery(`${query}&limit=${limit}`);\n    const pages = parseInt(result.page_total, 10);\n\n    if (pages > 1) {\n      throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);\n    }\n\n    return result.txs.map(restItem => ({\n      height: parseInt(restItem.height, 10),\n      hash: restItem.txhash,\n      code: restItem.code || 0,\n      rawLog: restItem.raw_log,\n      logs: logs_1.parseLogs(restItem.logs || []),\n      tx: restItem.tx,\n      timestamp: restItem.timestamp\n    }));\n  }\n\n}\n\nexports.CosmWasmClient = CosmWasmClient;","map":{"version":3,"sources":["../src/cosmwasmclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CosmWasmClient = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst launchpad_1 = require(\"@cosmjs/launchpad\");\nconst math_1 = require(\"@cosmjs/math\");\nconst wasm_1 = require(\"./lcdapi/wasm\");\nconst logs_1 = require(\"./logs\");\nfunction isSearchByIdQuery(query) {\n    return query.id !== undefined;\n}\nfunction isSearchByHeightQuery(query) {\n    return query.height !== undefined;\n}\nfunction isSearchBySentFromOrToQuery(query) {\n    return query.sentFromOrTo !== undefined;\n}\nfunction isSearchByTagsQuery(query) {\n    return query.tags !== undefined;\n}\nclass CosmWasmClient {\n    /**\n     * Creates a new client to interact with a CosmWasm blockchain.\n     *\n     * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n     * for the lifetime of your application. When switching backends, a new instance must be created.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n     */\n    constructor(apiUrl, broadcastMode = launchpad_1.BroadcastMode.Block) {\n        this.codesCache = new Map();\n        this.lcdClient = launchpad_1.LcdClient.withExtensions({ apiUrl: apiUrl, broadcastMode: broadcastMode }, launchpad_1.setupAuthExtension, wasm_1.setupWasmExtension);\n    }\n    async getChainId() {\n        if (!this.chainId) {\n            const response = await this.lcdClient.nodeInfo();\n            const chainId = response.node_info.network;\n            if (!chainId)\n                throw new Error(\"Chain ID must not be empty\");\n            this.chainId = chainId;\n        }\n        return this.chainId;\n    }\n    async getHeight() {\n        if (this.anyValidAddress) {\n            const { height } = await this.lcdClient.auth.account(this.anyValidAddress);\n            return parseInt(height, 10);\n        }\n        else {\n            // Note: this gets inefficient when blocks contain a lot of transactions since it\n            // requires downloading and deserializing all transactions in the block.\n            const latest = await this.lcdClient.blocksLatest();\n            return parseInt(latest.block.header.height, 10);\n        }\n    }\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n    async getIdentifier(tx) {\n        // We consult the REST API because we don't have a local amino encoder\n        const response = await this.lcdClient.encodeTx(tx);\n        const hash = new crypto_1.Sha256(encoding_1.fromBase64(response.tx)).digest();\n        return encoding_1.toHex(hash).toUpperCase();\n    }\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n    async getSequence(address) {\n        const account = await this.getAccount(address);\n        if (!account) {\n            throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n        }\n        return {\n            accountNumber: account.accountNumber,\n            sequence: account.sequence,\n        };\n    }\n    async getAccount(address) {\n        const account = await this.lcdClient.auth.account(address);\n        const value = account.result.value;\n        if (value.address === \"\") {\n            return undefined;\n        }\n        else {\n            this.anyValidAddress = value.address;\n            return {\n                address: value.address,\n                balance: value.coins,\n                pubkey: launchpad_1.normalizePubkey(value.public_key) || undefined,\n                accountNumber: launchpad_1.uint64ToNumber(value.account_number),\n                sequence: launchpad_1.uint64ToNumber(value.sequence),\n            };\n        }\n    }\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n    async getBlock(height) {\n        const response = height !== undefined ? await this.lcdClient.blocks(height) : await this.lcdClient.blocksLatest();\n        return {\n            id: response.block_id.hash,\n            header: {\n                version: response.block.header.version,\n                time: response.block.header.time,\n                height: parseInt(response.block.header.height, 10),\n                chainId: response.block.header.chain_id,\n            },\n            txs: (response.block.data.txs || []).map(encoding_1.fromBase64),\n        };\n    }\n    async searchTx(query, filter = {}) {\n        const minHeight = filter.minHeight || 0;\n        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n        if (maxHeight < minHeight)\n            return []; // optional optimization\n        function withFilters(originalQuery) {\n            return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;\n        }\n        let txs;\n        if (isSearchByIdQuery(query)) {\n            txs = await this.txsQuery(`tx.hash=${query.id}`);\n        }\n        else if (isSearchByHeightQuery(query)) {\n            // optional optimization to avoid network request\n            if (query.height < minHeight || query.height > maxHeight) {\n                txs = [];\n            }\n            else {\n                txs = await this.txsQuery(`tx.height=${query.height}`);\n            }\n        }\n        else if (isSearchBySentFromOrToQuery(query)) {\n            // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n            const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);\n            const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);\n            const [sent, received] = (await Promise.all([\n                this.txsQuery(sentQuery),\n                this.txsQuery(receivedQuery),\n            ]));\n            let mergedTxs = [];\n            /* eslint-disable @typescript-eslint/no-non-null-assertion */\n            // sent/received are presorted\n            while (sent.length && received.length) {\n                const next = sent[0].hash === received[0].hash\n                    ? sent.shift() && received.shift()\n                    : sent[0].height <= received[0].height\n                        ? sent.shift()\n                        : received.shift();\n                mergedTxs = [...mergedTxs, next];\n            }\n            /* eslint-enable @typescript-eslint/no-non-null-assertion */\n            // At least one of sent/received is empty by now\n            txs = [...mergedTxs, ...sent, ...received];\n        }\n        else if (isSearchByTagsQuery(query)) {\n            const rawQuery = withFilters(query.tags.map((t) => `${t.key}=${t.value}`).join(\"&\"));\n            txs = await this.txsQuery(rawQuery);\n        }\n        else {\n            throw new Error(\"Unknown query type\");\n        }\n        // backend sometimes messes up with min/max height filtering\n        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);\n        return filtered;\n    }\n    async postTx(tx) {\n        const result = await this.lcdClient.postTx(tx);\n        if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n            throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n        }\n        return result.code !== undefined\n            ? {\n                height: math_1.Uint53.fromString(result.height).toNumber(),\n                transactionHash: result.txhash,\n                code: result.code,\n                rawLog: result.raw_log || \"\",\n            }\n            : {\n                logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n                rawLog: result.raw_log || \"\",\n                transactionHash: result.txhash,\n                data: result.data ? encoding_1.fromHex(result.data) : undefined,\n            };\n    }\n    async getCodes() {\n        const result = await this.lcdClient.wasm.listCodeInfo();\n        return result.map((entry) => {\n            this.anyValidAddress = entry.creator;\n            return {\n                id: entry.id,\n                creator: entry.creator,\n                checksum: encoding_1.toHex(encoding_1.fromHex(entry.data_hash)),\n                source: entry.source || undefined,\n                builder: entry.builder || undefined,\n            };\n        });\n    }\n    async getCodeDetails(codeId) {\n        const cached = this.codesCache.get(codeId);\n        if (cached)\n            return cached;\n        const getCodeResult = await this.lcdClient.wasm.getCode(codeId);\n        const codeDetails = {\n            id: getCodeResult.id,\n            creator: getCodeResult.creator,\n            checksum: encoding_1.toHex(encoding_1.fromHex(getCodeResult.data_hash)),\n            source: getCodeResult.source || undefined,\n            builder: getCodeResult.builder || undefined,\n            data: encoding_1.fromBase64(getCodeResult.data),\n        };\n        this.codesCache.set(codeId, codeDetails);\n        return codeDetails;\n    }\n    async getContracts(codeId) {\n        const result = await this.lcdClient.wasm.listContractsByCodeId(codeId);\n        return result.map((entry) => ({\n            address: entry.address,\n            codeId: entry.code_id,\n            creator: entry.creator,\n            admin: entry.admin,\n            label: entry.label,\n        }));\n    }\n    /**\n     * Throws an error if no contract was found at the address\n     */\n    async getContract(address) {\n        const result = await this.lcdClient.wasm.getContractInfo(address);\n        if (!result)\n            throw new Error(`No contract found at address \"${address}\"`);\n        return {\n            address: result.address,\n            codeId: result.code_id,\n            creator: result.creator,\n            admin: result.admin,\n            label: result.label,\n        };\n    }\n    /**\n     * Throws an error if no contract was found at the address\n     */\n    async getContractCodeHistory(address) {\n        const result = await this.lcdClient.wasm.getContractCodeHistory(address);\n        if (!result)\n            throw new Error(`No contract history found for address \"${address}\"`);\n        return result.map((entry) => ({\n            operation: entry.operation,\n            codeId: entry.code_id,\n            msg: entry.msg,\n        }));\n    }\n    /**\n     * Returns the data at the key if present (raw contract dependent storage data)\n     * or null if no data at this key.\n     *\n     * Promise is rejected when contract does not exist.\n     */\n    async queryContractRaw(address, key) {\n        // just test contract existence\n        const _info = await this.getContract(address);\n        return this.lcdClient.wasm.queryContractRaw(address, key);\n    }\n    /**\n     * Makes a smart query on the contract, returns the parsed JSON document.\n     *\n     * Promise is rejected when contract does not exist.\n     * Promise is rejected for invalid query format.\n     * Promise is rejected for invalid response format.\n     */\n    async queryContractSmart(address, queryMsg) {\n        try {\n            return await this.lcdClient.wasm.queryContractSmart(address, queryMsg);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                if (error.message.startsWith(\"not found: contract\")) {\n                    throw new Error(`No contract found at address \"${address}\"`);\n                }\n                else {\n                    throw error;\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    async txsQuery(query) {\n        // TODO: we need proper pagination support\n        const limit = 100;\n        const result = await this.lcdClient.txsQuery(`${query}&limit=${limit}`);\n        const pages = parseInt(result.page_total, 10);\n        if (pages > 1) {\n            throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);\n        }\n        return result.txs.map((restItem) => ({\n            height: parseInt(restItem.height, 10),\n            hash: restItem.txhash,\n            code: restItem.code || 0,\n            rawLog: restItem.raw_log,\n            logs: logs_1.parseLogs(restItem.logs || []),\n            tx: restItem.tx,\n            timestamp: restItem.timestamp,\n        }));\n    }\n}\nexports.CosmWasmClient = CosmWasmClient;\n//# sourceMappingURL=cosmwasmclient.js.map"]},"metadata":{},"sourceType":"script"}