{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmosClient = exports.assertIsPostTxSuccess = exports.isPostTxSuccess = exports.isPostTxFailure = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nconst lcdapi_1 = require(\"./lcdapi\");\n\nconst logs_1 = require(\"./logs\");\n\nfunction isPostTxFailure(result) {\n  return !!result.code;\n}\n\nexports.isPostTxFailure = isPostTxFailure;\n\nfunction isPostTxSuccess(result) {\n  return !isPostTxFailure(result);\n}\n\nexports.isPostTxSuccess = isPostTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\n\nfunction assertIsPostTxSuccess(result) {\n  if (isPostTxFailure(result)) {\n    throw new Error(`Error when posting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n  }\n}\n\nexports.assertIsPostTxSuccess = assertIsPostTxSuccess;\n\nfunction isSearchByIdQuery(query) {\n  return query.id !== undefined;\n}\n\nfunction isSearchByHeightQuery(query) {\n  return query.height !== undefined;\n}\n\nfunction isSearchBySentFromOrToQuery(query) {\n  return query.sentFromOrTo !== undefined;\n}\n\nfunction isSearchByTagsQuery(query) {\n  return query.tags !== undefined;\n}\n\nclass CosmosClient {\n  /**\n   * Creates a new client to interact with a CosmWasm blockchain.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  constructor(apiUrl, broadcastMode = lcdapi_1.BroadcastMode.Block) {\n    this.lcdClient = lcdapi_1.LcdClient.withExtensions({\n      apiUrl: apiUrl,\n      broadcastMode: broadcastMode\n    }, lcdapi_1.setupAuthExtension);\n  }\n\n  async getChainId() {\n    if (!this.chainId) {\n      const response = await this.lcdClient.nodeInfo();\n      const chainId = response.node_info.network;\n      if (!chainId) throw new Error(\"Chain ID must not be empty\");\n      this.chainId = chainId;\n    }\n\n    return this.chainId;\n  }\n\n  async getHeight() {\n    if (this.anyValidAddress) {\n      const {\n        height\n      } = await this.lcdClient.auth.account(this.anyValidAddress);\n      return parseInt(height, 10);\n    } else {\n      // Note: this gets inefficient when blocks contain a lot of transactions since it\n      // requires downloading and deserializing all transactions in the block.\n      const latest = await this.lcdClient.blocksLatest();\n      return parseInt(latest.block.header.height, 10);\n    }\n  }\n  /**\n   * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n   */\n\n\n  async getIdentifier(tx) {\n    // We consult the REST API because we don't have a local amino encoder\n    const response = await this.lcdClient.encodeTx(tx);\n    const hash = new crypto_1.Sha256(encoding_1.fromBase64(response.tx)).digest();\n    return encoding_1.toHex(hash).toUpperCase();\n  }\n  /**\n   * Returns account number and sequence.\n   *\n   * Throws if the account does not exist on chain.\n   *\n   * @param address returns data for this address. When unset, the client's sender adddress is used.\n   */\n\n\n  async getSequence(address) {\n    const account = await this.getAccount(address);\n\n    if (!account) {\n      throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n    }\n\n    return {\n      accountNumber: account.accountNumber,\n      sequence: account.sequence\n    };\n  }\n\n  async getAccount(address) {\n    const account = await this.lcdClient.auth.account(address);\n    const value = account.result.value;\n\n    if (value.address === \"\") {\n      return undefined;\n    } else {\n      this.anyValidAddress = value.address;\n      return {\n        address: value.address,\n        balance: value.coins,\n        pubkey: lcdapi_1.normalizePubkey(value.public_key) || undefined,\n        accountNumber: lcdapi_1.uint64ToNumber(value.account_number),\n        sequence: lcdapi_1.uint64ToNumber(value.sequence)\n      };\n    }\n  }\n  /**\n   * Gets block header and meta\n   *\n   * @param height The height of the block. If undefined, the latest height is used.\n   */\n\n\n  async getBlock(height) {\n    const response = height !== undefined ? await this.lcdClient.blocks(height) : await this.lcdClient.blocksLatest();\n    return {\n      id: response.block_id.hash,\n      header: {\n        version: response.block.header.version,\n        time: response.block.header.time,\n        height: parseInt(response.block.header.height, 10),\n        chainId: response.block.header.chain_id\n      },\n      txs: (response.block.data.txs || []).map(encoding_1.fromBase64)\n    };\n  }\n\n  async searchTx(query, filter = {}) {\n    const minHeight = filter.minHeight || 0;\n    const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n    if (maxHeight < minHeight) return []; // optional optimization\n\n    function withFilters(originalQuery) {\n      return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;\n    }\n\n    let txs;\n\n    if (isSearchByIdQuery(query)) {\n      txs = await this.txsQuery(`tx.hash=${query.id}`);\n    } else if (isSearchByHeightQuery(query)) {\n      // optional optimization to avoid network request\n      if (query.height < minHeight || query.height > maxHeight) {\n        txs = [];\n      } else {\n        txs = await this.txsQuery(`tx.height=${query.height}`);\n      }\n    } else if (isSearchBySentFromOrToQuery(query)) {\n      // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n      const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);\n      const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);\n      const sent = await this.txsQuery(sentQuery);\n      const received = await this.txsQuery(receivedQuery);\n      const sentHashes = sent.map(t => t.hash);\n      txs = [...sent, ...received.filter(t => !sentHashes.includes(t.hash))];\n    } else if (isSearchByTagsQuery(query)) {\n      const rawQuery = withFilters(query.tags.map(t => `${t.key}=${t.value}`).join(\"&\"));\n      txs = await this.txsQuery(rawQuery);\n    } else {\n      throw new Error(\"Unknown query type\");\n    } // backend sometimes messes up with min/max height filtering\n\n\n    const filtered = txs.filter(tx => tx.height >= minHeight && tx.height <= maxHeight);\n    return filtered;\n  }\n\n  async postTx(tx) {\n    const result = await this.lcdClient.postTx(tx);\n\n    if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n      throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n    }\n\n    return result.code !== undefined ? {\n      height: math_1.Uint53.fromString(result.height).toNumber(),\n      transactionHash: result.txhash,\n      code: result.code,\n      rawLog: result.raw_log || \"\"\n    } : {\n      logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n      rawLog: result.raw_log || \"\",\n      transactionHash: result.txhash,\n      data: result.data ? encoding_1.fromHex(result.data) : undefined\n    };\n  }\n\n  async txsQuery(query) {\n    // TODO: we need proper pagination support\n    const limit = 100;\n    const result = await this.lcdClient.txsQuery(`${query}&limit=${limit}`);\n    const pages = parseInt(result.page_total, 10);\n\n    if (pages > 1) {\n      throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);\n    }\n\n    return result.txs.map(restItem => ({\n      height: parseInt(restItem.height, 10),\n      hash: restItem.txhash,\n      code: restItem.code || 0,\n      rawLog: restItem.raw_log,\n      logs: logs_1.parseLogs(restItem.logs || []),\n      tx: restItem.tx,\n      timestamp: restItem.timestamp\n    }));\n  }\n\n}\n\nexports.CosmosClient = CosmosClient;","map":{"version":3,"sources":["../src/cosmosclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CosmosClient = exports.assertIsPostTxSuccess = exports.isPostTxSuccess = exports.isPostTxFailure = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst lcdapi_1 = require(\"./lcdapi\");\nconst logs_1 = require(\"./logs\");\nfunction isPostTxFailure(result) {\n    return !!result.code;\n}\nexports.isPostTxFailure = isPostTxFailure;\nfunction isPostTxSuccess(result) {\n    return !isPostTxFailure(result);\n}\nexports.isPostTxSuccess = isPostTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\nfunction assertIsPostTxSuccess(result) {\n    if (isPostTxFailure(result)) {\n        throw new Error(`Error when posting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n    }\n}\nexports.assertIsPostTxSuccess = assertIsPostTxSuccess;\nfunction isSearchByIdQuery(query) {\n    return query.id !== undefined;\n}\nfunction isSearchByHeightQuery(query) {\n    return query.height !== undefined;\n}\nfunction isSearchBySentFromOrToQuery(query) {\n    return query.sentFromOrTo !== undefined;\n}\nfunction isSearchByTagsQuery(query) {\n    return query.tags !== undefined;\n}\nclass CosmosClient {\n    /**\n     * Creates a new client to interact with a CosmWasm blockchain.\n     *\n     * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n     * for the lifetime of your application. When switching backends, a new instance must be created.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n     */\n    constructor(apiUrl, broadcastMode = lcdapi_1.BroadcastMode.Block) {\n        this.lcdClient = lcdapi_1.LcdClient.withExtensions({ apiUrl: apiUrl, broadcastMode: broadcastMode }, lcdapi_1.setupAuthExtension);\n    }\n    async getChainId() {\n        if (!this.chainId) {\n            const response = await this.lcdClient.nodeInfo();\n            const chainId = response.node_info.network;\n            if (!chainId)\n                throw new Error(\"Chain ID must not be empty\");\n            this.chainId = chainId;\n        }\n        return this.chainId;\n    }\n    async getHeight() {\n        if (this.anyValidAddress) {\n            const { height } = await this.lcdClient.auth.account(this.anyValidAddress);\n            return parseInt(height, 10);\n        }\n        else {\n            // Note: this gets inefficient when blocks contain a lot of transactions since it\n            // requires downloading and deserializing all transactions in the block.\n            const latest = await this.lcdClient.blocksLatest();\n            return parseInt(latest.block.header.height, 10);\n        }\n    }\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n    async getIdentifier(tx) {\n        // We consult the REST API because we don't have a local amino encoder\n        const response = await this.lcdClient.encodeTx(tx);\n        const hash = new crypto_1.Sha256(encoding_1.fromBase64(response.tx)).digest();\n        return encoding_1.toHex(hash).toUpperCase();\n    }\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n    async getSequence(address) {\n        const account = await this.getAccount(address);\n        if (!account) {\n            throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n        }\n        return {\n            accountNumber: account.accountNumber,\n            sequence: account.sequence,\n        };\n    }\n    async getAccount(address) {\n        const account = await this.lcdClient.auth.account(address);\n        const value = account.result.value;\n        if (value.address === \"\") {\n            return undefined;\n        }\n        else {\n            this.anyValidAddress = value.address;\n            return {\n                address: value.address,\n                balance: value.coins,\n                pubkey: lcdapi_1.normalizePubkey(value.public_key) || undefined,\n                accountNumber: lcdapi_1.uint64ToNumber(value.account_number),\n                sequence: lcdapi_1.uint64ToNumber(value.sequence),\n            };\n        }\n    }\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n    async getBlock(height) {\n        const response = height !== undefined ? await this.lcdClient.blocks(height) : await this.lcdClient.blocksLatest();\n        return {\n            id: response.block_id.hash,\n            header: {\n                version: response.block.header.version,\n                time: response.block.header.time,\n                height: parseInt(response.block.header.height, 10),\n                chainId: response.block.header.chain_id,\n            },\n            txs: (response.block.data.txs || []).map(encoding_1.fromBase64),\n        };\n    }\n    async searchTx(query, filter = {}) {\n        const minHeight = filter.minHeight || 0;\n        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n        if (maxHeight < minHeight)\n            return []; // optional optimization\n        function withFilters(originalQuery) {\n            return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;\n        }\n        let txs;\n        if (isSearchByIdQuery(query)) {\n            txs = await this.txsQuery(`tx.hash=${query.id}`);\n        }\n        else if (isSearchByHeightQuery(query)) {\n            // optional optimization to avoid network request\n            if (query.height < minHeight || query.height > maxHeight) {\n                txs = [];\n            }\n            else {\n                txs = await this.txsQuery(`tx.height=${query.height}`);\n            }\n        }\n        else if (isSearchBySentFromOrToQuery(query)) {\n            // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n            const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);\n            const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);\n            const sent = await this.txsQuery(sentQuery);\n            const received = await this.txsQuery(receivedQuery);\n            const sentHashes = sent.map((t) => t.hash);\n            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];\n        }\n        else if (isSearchByTagsQuery(query)) {\n            const rawQuery = withFilters(query.tags.map((t) => `${t.key}=${t.value}`).join(\"&\"));\n            txs = await this.txsQuery(rawQuery);\n        }\n        else {\n            throw new Error(\"Unknown query type\");\n        }\n        // backend sometimes messes up with min/max height filtering\n        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);\n        return filtered;\n    }\n    async postTx(tx) {\n        const result = await this.lcdClient.postTx(tx);\n        if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n            throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n        }\n        return result.code !== undefined\n            ? {\n                height: math_1.Uint53.fromString(result.height).toNumber(),\n                transactionHash: result.txhash,\n                code: result.code,\n                rawLog: result.raw_log || \"\",\n            }\n            : {\n                logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n                rawLog: result.raw_log || \"\",\n                transactionHash: result.txhash,\n                data: result.data ? encoding_1.fromHex(result.data) : undefined,\n            };\n    }\n    async txsQuery(query) {\n        // TODO: we need proper pagination support\n        const limit = 100;\n        const result = await this.lcdClient.txsQuery(`${query}&limit=${limit}`);\n        const pages = parseInt(result.page_total, 10);\n        if (pages > 1) {\n            throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);\n        }\n        return result.txs.map((restItem) => ({\n            height: parseInt(restItem.height, 10),\n            hash: restItem.txhash,\n            code: restItem.code || 0,\n            rawLog: restItem.raw_log,\n            logs: logs_1.parseLogs(restItem.logs || []),\n            tx: restItem.tx,\n            timestamp: restItem.timestamp,\n        }));\n    }\n}\nexports.CosmosClient = CosmosClient;\n//# sourceMappingURL=cosmosclient.js.map"]},"metadata":{},"sourceType":"script"}