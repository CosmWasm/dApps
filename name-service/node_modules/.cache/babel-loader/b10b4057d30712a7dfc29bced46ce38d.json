{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst createHash = require(\"create-hash\");\n\nconst pbkdf2_1 = require(\"pbkdf2\");\n\nconst randomBytes = require(\"randombytes\");\n\nconst _wordlists_1 = require(\"./_wordlists\");\n\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please explicitly pass a 2048 word array explicitly.';\n\nfunction lpad(str, padString, length) {\n  while (str.length < length) str = padString + str;\n\n  return str;\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = createHash('sha256').update(entropyBuffer).digest();\n  return bytesToBinary([...hash]).slice(0, CS);\n}\n\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\n\nfunction mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n  const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n  return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\n\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n\nfunction mnemonicToSeed(mnemonic, password) {\n  return new Promise((resolve, reject) => {\n    try {\n      const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n      const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n      pbkdf2_1.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {\n        if (err) return reject(err);else return resolve(data);\n      });\n    } catch (error) {\n      return reject(error);\n    }\n  });\n}\n\nexports.mnemonicToSeed = mnemonicToSeed;\n\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n\n  const words = (mnemonic || '').normalize('NFKD').split(' ');\n  if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n    if (index === -1) throw new Error(INVALID_MNEMONIC);\n    return lpad(index.toString(2), '0', 11);\n  }).join(''); // split the binary string into ENT/CS\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n  if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY);\n  const entropy = Buffer.from(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM);\n  return entropy.toString('hex');\n}\n\nexports.mnemonicToEntropy = mnemonicToEntropy;\n\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex');\n  wordlist = wordlist || DEFAULT_WORDLIST;\n\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  } // 128 <= ENT <= 256\n\n\n  if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY);\n  const entropyBits = bytesToBinary([...entropy]);\n  const checksumBits = deriveChecksumBits(entropy);\n  const bits = entropyBits + checksumBits;\n  const chunks = bits.match(/(.{1,11})/g);\n  const words = chunks.map(binary => {\n    const index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n  ? words.join('\\u3000') : words.join(' ');\n}\n\nexports.entropyToMnemonic = entropyToMnemonic;\n\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n  if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY);\n  rng = rng || randomBytes;\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\n\nexports.generateMnemonic = generateMnemonic;\n\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.validateMnemonic = validateMnemonic;\n\nfunction setDefaultWordlist(language) {\n  const result = _wordlists_1.wordlists[language];\n  if (result) DEFAULT_WORDLIST = result;else throw new Error('Could not find wordlist for language \"' + language + '\"');\n}\n\nexports.setDefaultWordlist = setDefaultWordlist;\n\nfunction getDefaultWordlist() {\n  if (!DEFAULT_WORDLIST) throw new Error('No Default Wordlist set');\n  return Object.keys(_wordlists_1.wordlists).filter(lang => {\n    if (lang === 'JA' || lang === 'EN') return false;\n    return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n  })[0];\n}\n\nexports.getDefaultWordlist = getDefaultWordlist;\n\nvar _wordlists_2 = require(\"./_wordlists\");\n\nexports.wordlists = _wordlists_2.wordlists;","map":{"version":3,"sources":["/home/abefernan/cosmwasm/dApps/node_modules/bip39/src/index.js"],"names":["Object","defineProperty","exports","value","createHash","require","pbkdf2_1","randomBytes","_wordlists_1","DEFAULT_WORDLIST","_default","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","WORDLIST_REQUIRED","lpad","str","padString","length","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","join","deriveChecksumBits","entropyBuffer","ENT","CS","hash","update","digest","slice","salt","password","mnemonicToSeedSync","mnemonic","mnemonicBuffer","Buffer","from","normalize","saltBuffer","pbkdf2Sync","mnemonicToSeed","Promise","resolve","reject","pbkdf2","err","data","error","mnemonicToEntropy","wordlist","Error","words","split","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","isBuffer","TypeError","chunks","binary","generateMnemonic","strength","rng","validateMnemonic","e","setDefaultWordlist","language","result","wordlists","getDefaultWordlist","keys","filter","lang","every","_wordlists_2"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHash = require(\"create-hash\");\nconst pbkdf2_1 = require(\"pbkdf2\");\nconst randomBytes = require(\"randombytes\");\nconst _wordlists_1 = require(\"./_wordlists\");\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\n    'Please explicitly pass a 2048 word array explicitly.';\nfunction lpad(str, padString, length) {\n    while (str.length < length)\n        str = padString + str;\n    return str;\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = createHash('sha256')\n        .update(entropyBuffer)\n        .digest();\n    return bytesToBinary([...hash]).slice(0, CS);\n}\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n    const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n    return new Promise((resolve, reject) => {\n        try {\n            const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n            const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n            pbkdf2_1.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {\n                if (err)\n                    return reject(err);\n                else\n                    return resolve(data);\n            });\n        }\n        catch (error) {\n            return reject(error);\n        }\n    });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    const words = (mnemonic || '').normalize('NFKD').split(' ');\n    if (words.length % 3 !== 0)\n        throw new Error(INVALID_MNEMONIC);\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map(word => {\n        const index = wordlist.indexOf(word);\n        if (index === -1)\n            throw new Error(INVALID_MNEMONIC);\n        return lpad(index.toString(2), '0', 11);\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16)\n        throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length > 32)\n        throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length % 4 !== 0)\n        throw new Error(INVALID_ENTROPY);\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits)\n        throw new Error(INVALID_CHECKSUM);\n    return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy))\n        entropy = Buffer.from(entropy, 'hex');\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    // 128 <= ENT <= 256\n    if (entropy.length < 16)\n        throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length > 32)\n        throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length % 4 !== 0)\n        throw new TypeError(INVALID_ENTROPY);\n    const entropyBits = bytesToBinary([...entropy]);\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map(binary => {\n        const index = binaryToByte(binary);\n        return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n        ? words.join('\\u3000')\n        : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0)\n        throw new TypeError(INVALID_ENTROPY);\n    rng = rng || randomBytes;\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n    const result = _wordlists_1.wordlists[language];\n    if (result)\n        DEFAULT_WORDLIST = result;\n    else\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST)\n        throw new Error('No Default Wordlist set');\n    return Object.keys(_wordlists_1.wordlists).filter(lang => {\n        if (lang === 'JA' || lang === 'EN')\n            return false;\n        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = require(\"./_wordlists\");\nexports.wordlists = _wordlists_2.wordlists;\n"]},"metadata":{},"sourceType":"script"}