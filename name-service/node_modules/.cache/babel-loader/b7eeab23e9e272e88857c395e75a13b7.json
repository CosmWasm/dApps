{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromUtf8 = exports.toUtf8 = void 0;\n\nfunction isValidUtf8(data) {\n  const toStringAndBack = Buffer.from(Buffer.from(data).toString(\"utf8\"), \"utf8\");\n  return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;\n}\n\nfunction toUtf8(str) {\n  // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n  if (typeof TextEncoder !== \"undefined\") {\n    return new TextEncoder().encode(str);\n  } // Use Buffer hack instead of nodejs util.TextEncoder to ensure\n  // webpack does not bundle the util module for browsers.\n\n\n  return new Uint8Array(Buffer.from(str, \"utf8\"));\n}\n\nexports.toUtf8 = toUtf8;\n\nfunction fromUtf8(data) {\n  // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder(\"utf-8\", {\n      fatal: true\n    }).decode(data);\n  } // Use Buffer hack instead of nodejs util.TextDecoder to ensure\n  // webpack does not bundle the util module for browsers.\n  // Buffer.toString has no fatal option\n\n\n  if (!isValidUtf8(data)) {\n    throw new Error(\"Invalid UTF8 data\");\n  }\n\n  return Buffer.from(data).toString(\"utf8\");\n}\n\nexports.fromUtf8 = fromUtf8;","map":{"version":3,"sources":["../src/utf8.ts"],"names":[],"mappings":";;;;;;;AAQA,SAAS,WAAT,CAAqB,IAArB,EAAqC;AACnC,QAAM,eAAe,GAAG,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,CAA2B,MAA3B,CAAZ,EAAgD,MAAhD,CAAxB;AACA,SAAO,MAAM,CAAC,OAAP,CAAe,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAf,EAAkC,eAAlC,MAAuD,CAA9D;AACD;;AAED,SAAgB,MAAhB,CAAuB,GAAvB,EAAkC;AAChC;AACA,MAAI,OAAO,WAAP,KAAuB,WAA3B,EAAwC;AACtC,WAAO,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,GAAzB,CAAP;AACD,GAJ+B,CAMhC;AACA;;;AACA,SAAO,IAAI,UAAJ,CAAe,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,MAAjB,CAAf,CAAP;AACD;;AATD,OAAA,CAAA,MAAA,GAAA,MAAA;;AAWA,SAAgB,QAAhB,CAAyB,IAAzB,EAAyC;AACvC;AACA,MAAI,OAAO,WAAP,KAAuB,WAA3B,EAAwC;AACtC,WAAO,IAAI,WAAJ,CAAgB,OAAhB,EAAyB;AAAE,MAAA,KAAK,EAAE;AAAT,KAAzB,EAA0C,MAA1C,CAAiD,IAAjD,CAAP;AACD,GAJsC,CAMvC;AACA;AACA;;;AACA,MAAI,CAAC,WAAW,CAAC,IAAD,CAAhB,EAAwB;AACtB,UAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD;;AACD,SAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,CAA2B,MAA3B,CAAP;AACD;;AAbD,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromUtf8 = exports.toUtf8 = void 0;\nfunction isValidUtf8(data) {\n    const toStringAndBack = Buffer.from(Buffer.from(data).toString(\"utf8\"), \"utf8\");\n    return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;\n}\nfunction toUtf8(str) {\n    // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n    if (typeof TextEncoder !== \"undefined\") {\n        return new TextEncoder().encode(str);\n    }\n    // Use Buffer hack instead of nodejs util.TextEncoder to ensure\n    // webpack does not bundle the util module for browsers.\n    return new Uint8Array(Buffer.from(str, \"utf8\"));\n}\nexports.toUtf8 = toUtf8;\nfunction fromUtf8(data) {\n    // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n    if (typeof TextDecoder !== \"undefined\") {\n        return new TextDecoder(\"utf-8\", { fatal: true }).decode(data);\n    }\n    // Use Buffer hack instead of nodejs util.TextDecoder to ensure\n    // webpack does not bundle the util module for browsers.\n    // Buffer.toString has no fatal option\n    if (!isValidUtf8(data)) {\n        throw new Error(\"Invalid UTF8 data\");\n    }\n    return Buffer.from(data).toString(\"utf8\");\n}\nexports.fromUtf8 = fromUtf8;\n//# sourceMappingURL=utf8.js.map"]},"metadata":{},"sourceType":"script"}