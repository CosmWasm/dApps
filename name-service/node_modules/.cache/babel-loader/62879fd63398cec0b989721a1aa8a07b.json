{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findSequenceForSignedTx = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"./encoding\");\n\nconst signature_1 = require(\"./signature\");\n/**\n * Serach for sequence s with `min` <= `s` < `upperBound` to find the sequence that was used to sign the transaction\n *\n * @param tx The signed transaction\n * @param chainId The chain ID for which this transaction was signed\n * @param accountNumber The account number for which this transaction was signed\n * @param upperBound The upper bound for the testing, i.e. sequence must be lower than this value\n * @param min The lowest sequence that is tested\n *\n * @returns the sequence if a match was found and undefined otherwise\n */\n\n\nasync function findSequenceForSignedTx(tx, chainId, accountNumber, upperBound, min = 0) {\n  const firstSignature = tx.value.signatures.find(() => true);\n  if (!firstSignature) throw new Error(\"Signature missing in tx\");\n  const {\n    pubkey,\n    signature\n  } = signature_1.decodeSignature(firstSignature);\n  const secp256keSignature = crypto_1.Secp256k1Signature.fromFixedLength(signature);\n\n  for (let s = min; s < upperBound; s++) {\n    // console.log(`Trying sequence ${s}`);\n    const signBytes = encoding_1.makeSignBytes(tx.value.msg, tx.value.fee, chainId, tx.value.memo || \"\", accountNumber, s);\n    const prehashed = new crypto_1.Sha256(signBytes).digest();\n    const valid = await crypto_1.Secp256k1.verifySignature(secp256keSignature, prehashed, pubkey);\n    if (valid) return s;\n  }\n\n  return undefined;\n}\n\nexports.findSequenceForSignedTx = findSequenceForSignedTx;","map":{"version":3,"sources":["../src/sequence.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAGA;;;;;;;;;;;;;AAWO,eAAe,uBAAf,CACL,EADK,EAEL,OAFK,EAGL,aAHK,EAIL,UAJK,EAKL,GAAG,GAAG,CALD,EAKE;AAEP,QAAM,cAAc,GAAG,EAAE,CAAC,KAAH,CAAS,UAAT,CAAoB,IAApB,CAAyB,MAAM,IAA/B,CAAvB;AACA,MAAI,CAAC,cAAL,EAAqB,MAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AAErB,QAAM;AAAE,IAAA,MAAF;AAAU,IAAA;AAAV,MAAwB,WAAA,CAAA,eAAA,CAAgB,cAAhB,CAA9B;AACA,QAAM,kBAAkB,GAAG,QAAA,CAAA,kBAAA,CAAmB,eAAnB,CAAmC,SAAnC,CAA3B;;AAEA,OAAK,IAAI,CAAC,GAAG,GAAb,EAAkB,CAAC,GAAG,UAAtB,EAAkC,CAAC,EAAnC,EAAuC;AACrC;AACA,UAAM,SAAS,GAAG,UAAA,CAAA,aAAA,CAChB,EAAE,CAAC,KAAH,CAAS,GADO,EAEhB,EAAE,CAAC,KAAH,CAAS,GAFO,EAGhB,OAHgB,EAIhB,EAAE,CAAC,KAAH,CAAS,IAAT,IAAiB,EAJD,EAKhB,aALgB,EAMhB,CANgB,CAAlB;AAQA,UAAM,SAAS,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,SAAX,EAAsB,MAAtB,EAAlB;AACA,UAAM,KAAK,GAAG,MAAM,QAAA,CAAA,SAAA,CAAU,eAAV,CAA0B,kBAA1B,EAA8C,SAA9C,EAAyD,MAAzD,CAApB;AACA,QAAI,KAAJ,EAAW,OAAO,CAAP;AACZ;;AACD,SAAO,SAAP;AACD;;AA5BD,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findSequenceForSignedTx = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"./encoding\");\nconst signature_1 = require(\"./signature\");\n/**\n * Serach for sequence s with `min` <= `s` < `upperBound` to find the sequence that was used to sign the transaction\n *\n * @param tx The signed transaction\n * @param chainId The chain ID for which this transaction was signed\n * @param accountNumber The account number for which this transaction was signed\n * @param upperBound The upper bound for the testing, i.e. sequence must be lower than this value\n * @param min The lowest sequence that is tested\n *\n * @returns the sequence if a match was found and undefined otherwise\n */\nasync function findSequenceForSignedTx(tx, chainId, accountNumber, upperBound, min = 0) {\n    const firstSignature = tx.value.signatures.find(() => true);\n    if (!firstSignature)\n        throw new Error(\"Signature missing in tx\");\n    const { pubkey, signature } = signature_1.decodeSignature(firstSignature);\n    const secp256keSignature = crypto_1.Secp256k1Signature.fromFixedLength(signature);\n    for (let s = min; s < upperBound; s++) {\n        // console.log(`Trying sequence ${s}`);\n        const signBytes = encoding_1.makeSignBytes(tx.value.msg, tx.value.fee, chainId, tx.value.memo || \"\", accountNumber, s);\n        const prehashed = new crypto_1.Sha256(signBytes).digest();\n        const valid = await crypto_1.Secp256k1.verifySignature(secp256keSignature, prehashed, pubkey);\n        if (valid)\n            return s;\n    }\n    return undefined;\n}\nexports.findSequenceForSignedTx = findSequenceForSignedTx;\n//# sourceMappingURL=sequence.js.map"]},"metadata":{},"sourceType":"script"}