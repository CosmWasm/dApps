{"ast":null,"code":"'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this; // if we have detected an error in the meanwhile\n    // reject straight away\n\n\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this; // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n\n\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","map":{"version":3,"sources":["/home/abefernan/cosmwasm/dApps/node_modules/browserify-sign/node_modules/readable-stream/lib/internal/streams/async_iterator.js"],"names":["_Object$setPrototypeO","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","finished","require","kLastResolve","Symbol","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","done","readAndResolve","iter","resolve","data","read","onReadable","process","nextTick","wrapForNext","lastPromise","reject","then","undefined","AsyncIteratorPrototype","getPrototypeOf","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","stream","next","_this","error","Promise","destroyed","promise","asyncIterator","_return","_this2","destroy","err","createReadableStreamAsyncIterator","_Object$create","iterator","create","_readableState","endEmitted","code","on","bind","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;"]},"metadata":{},"sourceType":"script"}