{"ast":null,"code":"/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */\nmodule.exports = function (edges) {\n  return toposort(uniqueNodes(edges), edges);\n};\n\nmodule.exports.array = toposort;\n\nfunction toposort(nodes, edges) {\n  var cursor = nodes.length,\n      sorted = new Array(cursor),\n      visited = {},\n      i = cursor // Better data structures make algorithm much faster.\n  ,\n      outgoingEdges = makeOutgoingEdges(edges),\n      nodesHash = makeNodesHash(nodes); // check for unknown nodes\n\n  edges.forEach(function (edge) {\n    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {\n      throw new Error('Unknown node. There is an unknown node in the supplied edges.');\n    }\n  });\n\n  while (i--) {\n    if (!visited[i]) visit(nodes[i], i, new Set());\n  }\n\n  return sorted;\n\n  function visit(node, i, predecessors) {\n    if (predecessors.has(node)) {\n      var nodeRep;\n\n      try {\n        nodeRep = \", node was:\" + JSON.stringify(node);\n      } catch (e) {\n        nodeRep = \"\";\n      }\n\n      throw new Error('Cyclic dependency' + nodeRep);\n    }\n\n    if (!nodesHash.has(node)) {\n      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(node));\n    }\n\n    if (visited[i]) return;\n    visited[i] = true;\n    var outgoing = outgoingEdges.get(node) || new Set();\n    outgoing = Array.from(outgoing);\n\n    if (i = outgoing.length) {\n      predecessors.add(node);\n\n      do {\n        var child = outgoing[--i];\n        visit(child, nodesHash.get(child), predecessors);\n      } while (i);\n\n      predecessors.delete(node);\n    }\n\n    sorted[--cursor] = node;\n  }\n}\n\nfunction uniqueNodes(arr) {\n  var res = new Set();\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i];\n    res.add(edge[0]);\n    res.add(edge[1]);\n  }\n\n  return Array.from(res);\n}\n\nfunction makeOutgoingEdges(arr) {\n  var edges = new Map();\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i];\n    if (!edges.has(edge[0])) edges.set(edge[0], new Set());\n    if (!edges.has(edge[1])) edges.set(edge[1], new Set());\n    edges.get(edge[0]).add(edge[1]);\n  }\n\n  return edges;\n}\n\nfunction makeNodesHash(arr) {\n  var res = new Map();\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res.set(arr[i], i);\n  }\n\n  return res;\n}","map":{"version":3,"sources":["/home/abefernan/cosmwasm/dApps/node_modules/toposort/index.js"],"names":["module","exports","edges","toposort","uniqueNodes","array","nodes","cursor","length","sorted","Array","visited","i","outgoingEdges","makeOutgoingEdges","nodesHash","makeNodesHash","forEach","edge","has","Error","visit","Set","node","predecessors","nodeRep","JSON","stringify","e","outgoing","get","from","add","child","delete","arr","res","len","Map","set"],"mappings":"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","sourcesContent":["\n/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */\n\nmodule.exports = function(edges) {\n  return toposort(uniqueNodes(edges), edges)\n}\n\nmodule.exports.array = toposort\n\nfunction toposort(nodes, edges) {\n  var cursor = nodes.length\n    , sorted = new Array(cursor)\n    , visited = {}\n    , i = cursor\n    // Better data structures make algorithm much faster.\n    , outgoingEdges = makeOutgoingEdges(edges)\n    , nodesHash = makeNodesHash(nodes)\n\n  // check for unknown nodes\n  edges.forEach(function(edge) {\n    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {\n      throw new Error('Unknown node. There is an unknown node in the supplied edges.')\n    }\n  })\n\n  while (i--) {\n    if (!visited[i]) visit(nodes[i], i, new Set())\n  }\n\n  return sorted\n\n  function visit(node, i, predecessors) {\n    if(predecessors.has(node)) {\n      var nodeRep\n      try {\n        nodeRep = \", node was:\" + JSON.stringify(node)\n      } catch(e) {\n        nodeRep = \"\"\n      }\n      throw new Error('Cyclic dependency' + nodeRep)\n    }\n\n    if (!nodesHash.has(node)) {\n      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))\n    }\n\n    if (visited[i]) return;\n    visited[i] = true\n\n    var outgoing = outgoingEdges.get(node) || new Set()\n    outgoing = Array.from(outgoing)\n\n    if (i = outgoing.length) {\n      predecessors.add(node)\n      do {\n        var child = outgoing[--i]\n        visit(child, nodesHash.get(child), predecessors)\n      } while (i)\n      predecessors.delete(node)\n    }\n\n    sorted[--cursor] = node\n  }\n}\n\nfunction uniqueNodes(arr){\n  var res = new Set()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    res.add(edge[0])\n    res.add(edge[1])\n  }\n  return Array.from(res)\n}\n\nfunction makeOutgoingEdges(arr){\n  var edges = new Map()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    if (!edges.has(edge[0])) edges.set(edge[0], new Set())\n    if (!edges.has(edge[1])) edges.set(edge[1], new Set())\n    edges.get(edge[0]).add(edge[1])\n  }\n  return edges\n}\n\nfunction makeNodesHash(arr){\n  var res = new Map()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res.set(arr[i], i)\n  }\n  return res\n}\n"]},"metadata":{},"sourceType":"script"}