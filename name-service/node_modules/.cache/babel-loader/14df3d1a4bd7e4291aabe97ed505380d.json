{"ast":null,"code":"var _jsxFileName = \"/home/abefernan/cosmwasm/dApps/packages/name-service/src/service/error.tsx\";\nimport * as React from \"react\";\n/*\nUgly to use a singleton to manage functions, but the issue is that we want to return the same\nsetError, clearError functions to the consumers, so they don't trigger new effects everytime\nwe update the error state, which can lead to an infinite loop:\n\nComponent.useEffect returns error, calls setError\nErrorProvider updates value and returns new closure for setError\nuseEffect is triggered again, with another error....\n\nWhen this is updated, we only want things to re-render that depend on the actual error value.\nThere may be cleaner ways to do this but encapsulating a singleton here seemed fine.\n(We can't rely on local variables that change each time ErrorProvider() is called).\n*/\n\nlet initError; // this should be set on first render\n\nlet callback = state => {\n  // this is overriden on first render\n  initError = state.error;\n};\n\nfunction setError(err) {\n  const error = typeof err === \"string\" ? err : err.toString();\n  callback({\n    error\n  });\n}\n\nfunction clearError() {\n  callback({});\n}\n/** ****************/\n\n\nconst defaultContext = () => {\n  return {\n    setError,\n    clearError\n  };\n};\n\nconst ErrorContext = React.createContext(defaultContext());\nexport const useError = () => React.useContext(ErrorContext);\nexport function ErrorProvider(children) {\n  const [error, setError] = React.useState(undefined);\n  callback = setValue; // if there is an error before we render the first time, make sure we render it\n\n  if (initError) {\n    setValue({\n      error: initError\n    });\n    initError = undefined;\n  }\n\n  const context = {\n    error: error,\n    setError: setError,\n    clearError: () => {\n      setError(undefined);\n    }\n  };\n  return /*#__PURE__*/React.createElement(ErrorContext.Provider, {\n    value: context,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 74,\n      columnNumber: 10\n    }\n  }, children);\n}","map":{"version":3,"sources":["/home/abefernan/cosmwasm/dApps/packages/name-service/src/service/error.tsx"],"names":["React","initError","callback","state","error","setError","err","toString","clearError","defaultContext","ErrorContext","createContext","useError","useContext","ErrorProvider","children","useState","undefined","setValue","context"],"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA;;;;;;;;;;;;;;AAcA,IAAIC,SAAJ,C,CAEA;;AACA,IAAIC,QAAQ,GAAIC,KAAD,IAAwB;AACrC;AACAF,EAAAA,SAAS,GAAGE,KAAK,CAACC,KAAlB;AACD,CAHD;;AAKA,SAASC,QAAT,CAAkBC,GAAlB,EAAkC;AAChC,QAAMF,KAAK,GAAG,OAAOE,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCA,GAAG,CAACC,QAAJ,EAA9C;AACAL,EAAAA,QAAQ,CAAC;AAAEE,IAAAA;AAAF,GAAD,CAAR;AACD;;AAED,SAASI,UAAT,GAA4B;AAC1BN,EAAAA,QAAQ,CAAC,EAAD,CAAR;AACD;AAED;;;AAQA,MAAMO,cAAc,GAAG,MAAwB;AAC7C,SAAO;AACLJ,IAAAA,QADK;AAELG,IAAAA;AAFK,GAAP;AAID,CALD;;AAOA,MAAME,YAAY,GAAGV,KAAK,CAACW,aAAN,CAAsCF,cAAc,EAApD,CAArB;AAEA,OAAO,MAAMG,QAAQ,GAAG,MAAwBZ,KAAK,CAACa,UAAN,CAAiBH,YAAjB,CAAzC;AAMP,OAAO,SAASI,aAAT,CAAuBC,QAAvB,EAAsF;AAC3F,QAAM,CAACX,KAAD,EAAQC,QAAR,IAAoBL,KAAK,CAACgB,QAAN,CAAmCC,SAAnC,CAA1B;AACAf,EAAAA,QAAQ,GAAGgB,QAAX,CAF2F,CAG3F;;AACA,MAAIjB,SAAJ,EAAe;AACbiB,IAAAA,QAAQ,CAAC;AAAEd,MAAAA,KAAK,EAAEH;AAAT,KAAD,CAAR;AACAA,IAAAA,SAAS,GAAGgB,SAAZ;AACD;;AAED,QAAME,OAAyB,GAAG;AAChCf,IAAAA,KAAK,EAAEA,KADyB;AAEhCC,IAAAA,QAAQ,EAAEA,QAFsB;AAGhCG,IAAAA,UAAU,EAAE,MAAM;AAChBH,MAAAA,QAAQ,CAACY,SAAD,CAAR;AACD;AAL+B,GAAlC;AAQA,sBAAO,oBAAC,YAAD,CAAc,QAAd;AAAuB,IAAA,KAAK,EAAEE,OAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAwCJ,QAAxC,CAAP;AACD","sourcesContent":["import * as React from \"react\";\n\n/*\nUgly to use a singleton to manage functions, but the issue is that we want to return the same\nsetError, clearError functions to the consumers, so they don't trigger new effects everytime\nwe update the error state, which can lead to an infinite loop:\n\nComponent.useEffect returns error, calls setError\nErrorProvider updates value and returns new closure for setError\nuseEffect is triggered again, with another error....\n\nWhen this is updated, we only want things to re-render that depend on the actual error value.\nThere may be cleaner ways to do this but encapsulating a singleton here seemed fine.\n(We can't rely on local variables that change each time ErrorProvider() is called).\n*/\n\nlet initError: string | undefined;\n\n// this should be set on first render\nlet callback = (state: State): void => {\n  // this is overriden on first render\n  initError = state.error;\n};\n\nfunction setError(err: any): void {\n  const error = typeof err === \"string\" ? err : err.toString();\n  callback({ error });\n}\n\nfunction clearError(): void {\n  callback({});\n}\n\n/** ****************/\n\ninterface ErrorContextType {\n  readonly error?: string;\n  readonly setError: (err: string) => void;\n  readonly clearError: () => void;\n}\n\nconst defaultContext = (): ErrorContextType => {\n  return {\n    setError,\n    clearError,\n  };\n};\n\nconst ErrorContext = React.createContext<ErrorContextType>(defaultContext());\n\nexport const useError = (): ErrorContextType => React.useContext(ErrorContext);\n\ninterface State {\n  readonly error?: string;\n}\n\nexport function ErrorProvider(children: React.HTMLAttributes<HTMLOrSVGElement>): JSX.Element {\n  const [error, setError] = React.useState<string | undefined>(undefined);\n  callback = setValue;\n  // if there is an error before we render the first time, make sure we render it\n  if (initError) {\n    setValue({ error: initError });\n    initError = undefined;\n  }\n\n  const context: ErrorContextType = {\n    error: error,\n    setError: setError,\n    clearError: () => {\n      setError(undefined);\n    },\n  };\n\n  return <ErrorContext.Provider value={context}>{children}</ErrorContext.Provider>;\n}\n"]},"metadata":{},"sourceType":"module"}