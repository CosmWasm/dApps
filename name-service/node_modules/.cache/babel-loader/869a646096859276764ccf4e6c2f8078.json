{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pubkeyToAddress = exports.rawSecp256k1PubkeyToAddress = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst types_1 = require(\"./types\");\n\nfunction rawSecp256k1PubkeyToAddress(pubkeyRaw, prefix) {\n  if (pubkeyRaw.length !== 33) {\n    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyRaw.length}`);\n  }\n\n  const hash1 = new crypto_1.Sha256(pubkeyRaw).digest();\n  const hash2 = new crypto_1.Ripemd160(hash1).digest();\n  return encoding_1.Bech32.encode(prefix, hash2);\n}\n\nexports.rawSecp256k1PubkeyToAddress = rawSecp256k1PubkeyToAddress; // See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\n// This assumes we already have a cosmos-compressed pubkey\n\nfunction pubkeyToAddress(pubkey, prefix) {\n  const pubkeyBytes = encoding_1.fromBase64(pubkey.value);\n\n  switch (pubkey.type) {\n    case types_1.pubkeyType.secp256k1:\n      {\n        return rawSecp256k1PubkeyToAddress(pubkeyBytes, prefix);\n      }\n\n    case types_1.pubkeyType.ed25519:\n      {\n        if (pubkeyBytes.length !== 32) {\n          throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyBytes.length}`);\n        }\n\n        const hash = new crypto_1.Sha256(pubkeyBytes).digest();\n        return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n      }\n\n    case types_1.pubkeyType.sr25519:\n      {\n        if (pubkeyBytes.length !== 32) {\n          throw new Error(`Invalid Sr25519 pubkey length: ${pubkeyBytes.length}`);\n        }\n\n        const hash = new crypto_1.Sha256(pubkeyBytes).digest();\n        return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n      }\n\n    default:\n      throw new Error(\"Unrecognized public key algorithm\");\n  }\n}\n\nexports.pubkeyToAddress = pubkeyToAddress;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,SAAgB,2BAAhB,CAA4C,SAA5C,EAAmE,MAAnE,EAAiF;AAC/E,MAAI,SAAS,CAAC,MAAV,KAAqB,EAAzB,EAA6B;AAC3B,UAAM,IAAI,KAAJ,CAAU,iDAAiD,SAAS,CAAC,MAAM,EAA3E,CAAN;AACD;;AACD,QAAM,KAAK,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,SAAX,EAAsB,MAAtB,EAAd;AACA,QAAM,KAAK,GAAG,IAAI,QAAA,CAAA,SAAJ,CAAc,KAAd,EAAqB,MAArB,EAAd;AACA,SAAO,UAAA,CAAA,MAAA,CAAO,MAAP,CAAc,MAAd,EAAsB,KAAtB,CAAP;AACD;;AAPD,OAAA,CAAA,2BAAA,GAAA,2BAAA,C,CASA;AACA;;AACA,SAAgB,eAAhB,CAAgC,MAAhC,EAAgD,MAAhD,EAA8D;AAC5D,QAAM,WAAW,GAAG,UAAA,CAAA,UAAA,CAAW,MAAM,CAAC,KAAlB,CAApB;;AACA,UAAQ,MAAM,CAAC,IAAf;AACE,SAAK,OAAA,CAAA,UAAA,CAAW,SAAhB;AAA2B;AACzB,eAAO,2BAA2B,CAAC,WAAD,EAAc,MAAd,CAAlC;AACD;;AACD,SAAK,OAAA,CAAA,UAAA,CAAW,OAAhB;AAAyB;AACvB,YAAI,WAAW,CAAC,MAAZ,KAAuB,EAA3B,EAA+B;AAC7B,gBAAM,IAAI,KAAJ,CAAU,kCAAkC,WAAW,CAAC,MAAM,EAA9D,CAAN;AACD;;AACD,cAAM,IAAI,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,WAAX,EAAwB,MAAxB,EAAb;AACA,eAAO,UAAA,CAAA,MAAA,CAAO,MAAP,CAAc,MAAd,EAAsB,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,EAAd,CAAtB,CAAP;AACD;;AACD,SAAK,OAAA,CAAA,UAAA,CAAW,OAAhB;AAAyB;AACvB,YAAI,WAAW,CAAC,MAAZ,KAAuB,EAA3B,EAA+B;AAC7B,gBAAM,IAAI,KAAJ,CAAU,kCAAkC,WAAW,CAAC,MAAM,EAA9D,CAAN;AACD;;AACD,cAAM,IAAI,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,WAAX,EAAwB,MAAxB,EAAb;AACA,eAAO,UAAA,CAAA,MAAA,CAAO,MAAP,CAAc,MAAd,EAAsB,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,EAAd,CAAtB,CAAP;AACD;;AACD;AACE,YAAM,IAAI,KAAJ,CAAU,mCAAV,CAAN;AAnBJ;AAqBD;;AAvBD,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pubkeyToAddress = exports.rawSecp256k1PubkeyToAddress = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst types_1 = require(\"./types\");\nfunction rawSecp256k1PubkeyToAddress(pubkeyRaw, prefix) {\n    if (pubkeyRaw.length !== 33) {\n        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyRaw.length}`);\n    }\n    const hash1 = new crypto_1.Sha256(pubkeyRaw).digest();\n    const hash2 = new crypto_1.Ripemd160(hash1).digest();\n    return encoding_1.Bech32.encode(prefix, hash2);\n}\nexports.rawSecp256k1PubkeyToAddress = rawSecp256k1PubkeyToAddress;\n// See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\n// This assumes we already have a cosmos-compressed pubkey\nfunction pubkeyToAddress(pubkey, prefix) {\n    const pubkeyBytes = encoding_1.fromBase64(pubkey.value);\n    switch (pubkey.type) {\n        case types_1.pubkeyType.secp256k1: {\n            return rawSecp256k1PubkeyToAddress(pubkeyBytes, prefix);\n        }\n        case types_1.pubkeyType.ed25519: {\n            if (pubkeyBytes.length !== 32) {\n                throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyBytes.length}`);\n            }\n            const hash = new crypto_1.Sha256(pubkeyBytes).digest();\n            return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n        }\n        case types_1.pubkeyType.sr25519: {\n            if (pubkeyBytes.length !== 32) {\n                throw new Error(`Invalid Sr25519 pubkey length: ${pubkeyBytes.length}`);\n            }\n            const hash = new crypto_1.Sha256(pubkeyBytes).digest();\n            return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n        }\n        default:\n            throw new Error(\"Unrecognized public key algorithm\");\n    }\n}\nexports.pubkeyToAddress = pubkeyToAddress;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}