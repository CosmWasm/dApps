{"ast":null,"code":"import React from 'react';\nexport function toArrayChildren(children) {\n  var ret = [];\n  React.Children.forEach(children, function (child) {\n    ret.push(child);\n  });\n  return ret;\n}\nexport function findChildInChildrenByKey(children, key) {\n  var ret = null;\n\n  if (children) {\n    children.forEach(function (child) {\n      if (ret) {\n        return;\n      }\n\n      if (child && child.key === key) {\n        ret = child;\n      }\n    });\n  }\n\n  return ret;\n}\nexport function findShownChildInChildrenByKey(children, key, showProp) {\n  var ret = null;\n\n  if (children) {\n    children.forEach(function (child) {\n      if (child && child.key === key && child.props[showProp]) {\n        if (ret) {\n          throw new Error('two child with same key for <rc-animate> children');\n        }\n\n        ret = child;\n      }\n    });\n  }\n\n  return ret;\n}\nexport function findHiddenChildInChildrenByKey(children, key, showProp) {\n  var found = 0;\n\n  if (children) {\n    children.forEach(function (child) {\n      if (found) {\n        return;\n      }\n\n      found = child && child.key === key && !child.props[showProp];\n    });\n  }\n\n  return found;\n}\nexport function isSameChildren(c1, c2, showProp) {\n  var same = c1.length === c2.length;\n\n  if (same) {\n    c1.forEach(function (child, index) {\n      var child2 = c2[index];\n\n      if (child && child2) {\n        if (child && !child2 || !child && child2) {\n          same = false;\n        } else if (child.key !== child2.key) {\n          same = false;\n        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {\n          same = false;\n        }\n      }\n    });\n  }\n\n  return same;\n}\nexport function mergeChildren(prev, next) {\n  var ret = []; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n  var nextChildrenPending = {};\n  var pendingChildren = [];\n  prev.forEach(function (child) {\n    if (child && findChildInChildrenByKey(next, child.key)) {\n      if (pendingChildren.length) {\n        nextChildrenPending[child.key] = pendingChildren;\n        pendingChildren = [];\n      }\n    } else {\n      pendingChildren.push(child);\n    }\n  });\n  next.forEach(function (child) {\n    if (child && Object.prototype.hasOwnProperty.call(nextChildrenPending, child.key)) {\n      ret = ret.concat(nextChildrenPending[child.key]);\n    }\n\n    ret.push(child);\n  });\n  ret = ret.concat(pendingChildren);\n  return ret;\n}","map":{"version":3,"sources":["/home/abefernan/cosmwasm/dApps/node_modules/rc-animate/es/ChildrenUtils.js"],"names":["React","toArrayChildren","children","ret","Children","forEach","child","push","findChildInChildrenByKey","key","findShownChildInChildrenByKey","showProp","props","Error","findHiddenChildInChildrenByKey","found","isSameChildren","c1","c2","same","length","index","child2","mergeChildren","prev","next","nextChildrenPending","pendingChildren","Object","prototype","hasOwnProperty","call","concat"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAO,SAASC,eAAT,CAAyBC,QAAzB,EAAmC;AACxC,MAAIC,GAAG,GAAG,EAAV;AACAH,EAAAA,KAAK,CAACI,QAAN,CAAeC,OAAf,CAAuBH,QAAvB,EAAiC,UAAUI,KAAV,EAAiB;AAChDH,IAAAA,GAAG,CAACI,IAAJ,CAASD,KAAT;AACD,GAFD;AAGA,SAAOH,GAAP;AACD;AAED,OAAO,SAASK,wBAAT,CAAkCN,QAAlC,EAA4CO,GAA5C,EAAiD;AACtD,MAAIN,GAAG,GAAG,IAAV;;AACA,MAAID,QAAJ,EAAc;AACZA,IAAAA,QAAQ,CAACG,OAAT,CAAiB,UAAUC,KAAV,EAAiB;AAChC,UAAIH,GAAJ,EAAS;AACP;AACD;;AACD,UAAIG,KAAK,IAAIA,KAAK,CAACG,GAAN,KAAcA,GAA3B,EAAgC;AAC9BN,QAAAA,GAAG,GAAGG,KAAN;AACD;AACF,KAPD;AAQD;;AACD,SAAOH,GAAP;AACD;AAED,OAAO,SAASO,6BAAT,CAAuCR,QAAvC,EAAiDO,GAAjD,EAAsDE,QAAtD,EAAgE;AACrE,MAAIR,GAAG,GAAG,IAAV;;AACA,MAAID,QAAJ,EAAc;AACZA,IAAAA,QAAQ,CAACG,OAAT,CAAiB,UAAUC,KAAV,EAAiB;AAChC,UAAIA,KAAK,IAAIA,KAAK,CAACG,GAAN,KAAcA,GAAvB,IAA8BH,KAAK,CAACM,KAAN,CAAYD,QAAZ,CAAlC,EAAyD;AACvD,YAAIR,GAAJ,EAAS;AACP,gBAAM,IAAIU,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACDV,QAAAA,GAAG,GAAGG,KAAN;AACD;AACF,KAPD;AAQD;;AACD,SAAOH,GAAP;AACD;AAED,OAAO,SAASW,8BAAT,CAAwCZ,QAAxC,EAAkDO,GAAlD,EAAuDE,QAAvD,EAAiE;AACtE,MAAII,KAAK,GAAG,CAAZ;;AACA,MAAIb,QAAJ,EAAc;AACZA,IAAAA,QAAQ,CAACG,OAAT,CAAiB,UAAUC,KAAV,EAAiB;AAChC,UAAIS,KAAJ,EAAW;AACT;AACD;;AACDA,MAAAA,KAAK,GAAGT,KAAK,IAAIA,KAAK,CAACG,GAAN,KAAcA,GAAvB,IAA8B,CAACH,KAAK,CAACM,KAAN,CAAYD,QAAZ,CAAvC;AACD,KALD;AAMD;;AACD,SAAOI,KAAP;AACD;AAED,OAAO,SAASC,cAAT,CAAwBC,EAAxB,EAA4BC,EAA5B,EAAgCP,QAAhC,EAA0C;AAC/C,MAAIQ,IAAI,GAAGF,EAAE,CAACG,MAAH,KAAcF,EAAE,CAACE,MAA5B;;AACA,MAAID,IAAJ,EAAU;AACRF,IAAAA,EAAE,CAACZ,OAAH,CAAW,UAAUC,KAAV,EAAiBe,KAAjB,EAAwB;AACjC,UAAIC,MAAM,GAAGJ,EAAE,CAACG,KAAD,CAAf;;AACA,UAAIf,KAAK,IAAIgB,MAAb,EAAqB;AACnB,YAAIhB,KAAK,IAAI,CAACgB,MAAV,IAAoB,CAAChB,KAAD,IAAUgB,MAAlC,EAA0C;AACxCH,UAAAA,IAAI,GAAG,KAAP;AACD,SAFD,MAEO,IAAIb,KAAK,CAACG,GAAN,KAAca,MAAM,CAACb,GAAzB,EAA8B;AACnCU,UAAAA,IAAI,GAAG,KAAP;AACD,SAFM,MAEA,IAAIR,QAAQ,IAAIL,KAAK,CAACM,KAAN,CAAYD,QAAZ,MAA0BW,MAAM,CAACV,KAAP,CAAaD,QAAb,CAA1C,EAAkE;AACvEQ,UAAAA,IAAI,GAAG,KAAP;AACD;AACF;AACF,KAXD;AAYD;;AACD,SAAOA,IAAP;AACD;AAED,OAAO,SAASI,aAAT,CAAuBC,IAAvB,EAA6BC,IAA7B,EAAmC;AACxC,MAAItB,GAAG,GAAG,EAAV,CADwC,CAGxC;AACA;;AACA,MAAIuB,mBAAmB,GAAG,EAA1B;AACA,MAAIC,eAAe,GAAG,EAAtB;AACAH,EAAAA,IAAI,CAACnB,OAAL,CAAa,UAAUC,KAAV,EAAiB;AAC5B,QAAIA,KAAK,IAAIE,wBAAwB,CAACiB,IAAD,EAAOnB,KAAK,CAACG,GAAb,CAArC,EAAwD;AACtD,UAAIkB,eAAe,CAACP,MAApB,EAA4B;AAC1BM,QAAAA,mBAAmB,CAACpB,KAAK,CAACG,GAAP,CAAnB,GAAiCkB,eAAjC;AACAA,QAAAA,eAAe,GAAG,EAAlB;AACD;AACF,KALD,MAKO;AACLA,MAAAA,eAAe,CAACpB,IAAhB,CAAqBD,KAArB;AACD;AACF,GATD;AAWAmB,EAAAA,IAAI,CAACpB,OAAL,CAAa,UAAUC,KAAV,EAAiB;AAC5B,QAAIA,KAAK,IAAIsB,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,mBAArC,EAA0DpB,KAAK,CAACG,GAAhE,CAAb,EAAmF;AACjFN,MAAAA,GAAG,GAAGA,GAAG,CAAC6B,MAAJ,CAAWN,mBAAmB,CAACpB,KAAK,CAACG,GAAP,CAA9B,CAAN;AACD;;AACDN,IAAAA,GAAG,CAACI,IAAJ,CAASD,KAAT;AACD,GALD;AAOAH,EAAAA,GAAG,GAAGA,GAAG,CAAC6B,MAAJ,CAAWL,eAAX,CAAN;AAEA,SAAOxB,GAAP;AACD","sourcesContent":["import React from 'react';\n\nexport function toArrayChildren(children) {\n  var ret = [];\n  React.Children.forEach(children, function (child) {\n    ret.push(child);\n  });\n  return ret;\n}\n\nexport function findChildInChildrenByKey(children, key) {\n  var ret = null;\n  if (children) {\n    children.forEach(function (child) {\n      if (ret) {\n        return;\n      }\n      if (child && child.key === key) {\n        ret = child;\n      }\n    });\n  }\n  return ret;\n}\n\nexport function findShownChildInChildrenByKey(children, key, showProp) {\n  var ret = null;\n  if (children) {\n    children.forEach(function (child) {\n      if (child && child.key === key && child.props[showProp]) {\n        if (ret) {\n          throw new Error('two child with same key for <rc-animate> children');\n        }\n        ret = child;\n      }\n    });\n  }\n  return ret;\n}\n\nexport function findHiddenChildInChildrenByKey(children, key, showProp) {\n  var found = 0;\n  if (children) {\n    children.forEach(function (child) {\n      if (found) {\n        return;\n      }\n      found = child && child.key === key && !child.props[showProp];\n    });\n  }\n  return found;\n}\n\nexport function isSameChildren(c1, c2, showProp) {\n  var same = c1.length === c2.length;\n  if (same) {\n    c1.forEach(function (child, index) {\n      var child2 = c2[index];\n      if (child && child2) {\n        if (child && !child2 || !child && child2) {\n          same = false;\n        } else if (child.key !== child2.key) {\n          same = false;\n        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {\n          same = false;\n        }\n      }\n    });\n  }\n  return same;\n}\n\nexport function mergeChildren(prev, next) {\n  var ret = [];\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextChildrenPending = {};\n  var pendingChildren = [];\n  prev.forEach(function (child) {\n    if (child && findChildInChildrenByKey(next, child.key)) {\n      if (pendingChildren.length) {\n        nextChildrenPending[child.key] = pendingChildren;\n        pendingChildren = [];\n      }\n    } else {\n      pendingChildren.push(child);\n    }\n  });\n\n  next.forEach(function (child) {\n    if (child && Object.prototype.hasOwnProperty.call(nextChildrenPending, child.key)) {\n      ret = ret.concat(nextChildrenPending[child.key]);\n    }\n    ret.push(child);\n  });\n\n  ret = ret.concat(pendingChildren);\n\n  return ret;\n}"]},"metadata":{},"sourceType":"module"}