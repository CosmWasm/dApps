{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LcdClient = exports.normalizeLcdApiArray = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/naming-convention */\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst axios_1 = __importDefault(require(\"axios\"));\n\nconst base_1 = require(\"./base\");\n\nfunction normalizeLcdApiArray(backend) {\n  return backend || [];\n}\n\nexports.normalizeLcdApiArray = normalizeLcdApiArray; // We want to get message data from 500 errors\n// https://stackoverflow.com/questions/56577124/how-to-handle-500-error-message-with-axios\n// this should be chained to catch one error and throw a more informative one\n\nfunction parseAxiosError(err) {\n  var _a; // use the error message sent from server, not default 500 msg\n\n\n  if ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data) {\n    let errorText;\n    const data = err.response.data; // expect { error: string }, but otherwise dump\n\n    if (data.error && typeof data.error === \"string\") {\n      errorText = data.error;\n    } else if (typeof data === \"string\") {\n      errorText = data;\n    } else {\n      errorText = JSON.stringify(data);\n    }\n\n    throw new Error(`${errorText} (HTTP ${err.response.status})`);\n  } else {\n    throw err;\n  }\n}\n/**\n * A client to the LCD's (light client daemon) API.\n * This light client connects to Tendermint (i.e. the chain), encodes/decodes Amino data for us and provides a convenient JSON interface.\n *\n * This _JSON over HTTP_ API is sometimes referred to as \"REST\" or \"RPC\", which are both misleading terms\n * for the same thing.\n *\n * Please note that the client to the LCD can not verify light client proofs. When using this,\n * you need to trust the API provider as well as the network connection between client and API.\n *\n * @see https://cosmos.network/rpc\n */\n\n\nclass LcdClient {\n  /**\n   * Creates a new client to interact with a Cosmos SDK light client daemon.\n   * This class tries to be a direct mapping onto the API. Some basic decoding and normalizatin is done\n   * but things like caching are done at a higher level.\n   *\n   * When building apps, you should not need to use this class directly. If you do, this indicates a missing feature\n   * in higher level components. Feel free to raise an issue in this case.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  constructor(apiUrl, broadcastMode = base_1.BroadcastMode.Block) {\n    const headers = {\n      post: {\n        \"Content-Type\": \"application/json\"\n      }\n    };\n    this.client = axios_1.default.create({\n      baseURL: apiUrl,\n      headers: headers\n    });\n    this.broadcastMode = broadcastMode;\n  }\n\n  static withExtensions(options, ...extensionSetups) {\n    const client = new LcdClient(options.apiUrl, options.broadcastMode);\n    const extensions = extensionSetups.map(setupExtension => setupExtension(client));\n\n    for (const extension of extensions) {\n      utils_1.assert(utils_1.isNonNullObject(extension), `Extension must be a non-null object`);\n\n      for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n        utils_1.assert(utils_1.isNonNullObject(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n        const current = client[moduleKey] || {};\n        client[moduleKey] = Object.assign(Object.assign({}, current), moduleValue);\n      }\n    }\n\n    return client;\n  }\n\n  async get(path, params) {\n    const {\n      data\n    } = await this.client.get(path, {\n      params\n    }).catch(parseAxiosError);\n\n    if (data === null) {\n      throw new Error(\"Received null response from server\");\n    }\n\n    return data;\n  }\n\n  async post(path, params) {\n    if (!utils_1.isNonNullObject(params)) throw new Error(\"Got unexpected type of params. Expected object.\");\n    const {\n      data\n    } = await this.client.post(path, params).catch(parseAxiosError);\n\n    if (data === null) {\n      throw new Error(\"Received null response from server\");\n    }\n\n    return data;\n  } // The /blocks endpoints\n\n\n  async blocksLatest() {\n    const responseData = await this.get(\"/blocks/latest\");\n\n    if (!responseData.block) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  }\n\n  async blocks(height) {\n    const responseData = await this.get(`/blocks/${height}`);\n\n    if (!responseData.block) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  } // The /node_info endpoint\n\n\n  async nodeInfo() {\n    const responseData = await this.get(\"/node_info\");\n\n    if (!responseData.node_info) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  } // The /txs endpoints\n\n\n  async txById(id) {\n    const responseData = await this.get(`/txs/${id}`);\n\n    if (!responseData.tx) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  }\n\n  async txsQuery(query) {\n    const responseData = await this.get(`/txs?${query}`);\n\n    if (!responseData.txs) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  }\n  /** returns the amino-encoding of the transaction performed by the server */\n\n\n  async encodeTx(tx) {\n    const responseData = await this.post(\"/txs/encode\", tx);\n\n    if (!responseData.tx) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  }\n  /**\n   * Broadcasts a signed transaction to the transaction pool.\n   * Depending on the client's broadcast mode, this might or might\n   * wait for checkTx or deliverTx to be executed before returning.\n   *\n   * @param tx a signed transaction as StdTx (i.e. not wrapped in type/value container)\n   */\n\n\n  async postTx(tx) {\n    const params = {\n      tx: tx,\n      mode: this.broadcastMode\n    };\n    const responseData = await this.post(\"/txs\", params);\n\n    if (!responseData.txhash) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  }\n\n}\n\nexports.LcdClient = LcdClient;","map":{"version":3,"sources":["../../src/lcdapi/lcdclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LcdClient = exports.normalizeLcdApiArray = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/naming-convention */\nconst utils_1 = require(\"@cosmjs/utils\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst base_1 = require(\"./base\");\nfunction normalizeLcdApiArray(backend) {\n    return backend || [];\n}\nexports.normalizeLcdApiArray = normalizeLcdApiArray;\n// We want to get message data from 500 errors\n// https://stackoverflow.com/questions/56577124/how-to-handle-500-error-message-with-axios\n// this should be chained to catch one error and throw a more informative one\nfunction parseAxiosError(err) {\n    var _a;\n    // use the error message sent from server, not default 500 msg\n    if ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data) {\n        let errorText;\n        const data = err.response.data;\n        // expect { error: string }, but otherwise dump\n        if (data.error && typeof data.error === \"string\") {\n            errorText = data.error;\n        }\n        else if (typeof data === \"string\") {\n            errorText = data;\n        }\n        else {\n            errorText = JSON.stringify(data);\n        }\n        throw new Error(`${errorText} (HTTP ${err.response.status})`);\n    }\n    else {\n        throw err;\n    }\n}\n/**\n * A client to the LCD's (light client daemon) API.\n * This light client connects to Tendermint (i.e. the chain), encodes/decodes Amino data for us and provides a convenient JSON interface.\n *\n * This _JSON over HTTP_ API is sometimes referred to as \"REST\" or \"RPC\", which are both misleading terms\n * for the same thing.\n *\n * Please note that the client to the LCD can not verify light client proofs. When using this,\n * you need to trust the API provider as well as the network connection between client and API.\n *\n * @see https://cosmos.network/rpc\n */\nclass LcdClient {\n    /**\n     * Creates a new client to interact with a Cosmos SDK light client daemon.\n     * This class tries to be a direct mapping onto the API. Some basic decoding and normalizatin is done\n     * but things like caching are done at a higher level.\n     *\n     * When building apps, you should not need to use this class directly. If you do, this indicates a missing feature\n     * in higher level components. Feel free to raise an issue in this case.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n     */\n    constructor(apiUrl, broadcastMode = base_1.BroadcastMode.Block) {\n        const headers = {\n            post: { \"Content-Type\": \"application/json\" },\n        };\n        this.client = axios_1.default.create({\n            baseURL: apiUrl,\n            headers: headers,\n        });\n        this.broadcastMode = broadcastMode;\n    }\n    static withExtensions(options, ...extensionSetups) {\n        const client = new LcdClient(options.apiUrl, options.broadcastMode);\n        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));\n        for (const extension of extensions) {\n            utils_1.assert(utils_1.isNonNullObject(extension), `Extension must be a non-null object`);\n            for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n                utils_1.assert(utils_1.isNonNullObject(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n                const current = client[moduleKey] || {};\n                client[moduleKey] = Object.assign(Object.assign({}, current), moduleValue);\n            }\n        }\n        return client;\n    }\n    async get(path, params) {\n        const { data } = await this.client.get(path, { params }).catch(parseAxiosError);\n        if (data === null) {\n            throw new Error(\"Received null response from server\");\n        }\n        return data;\n    }\n    async post(path, params) {\n        if (!utils_1.isNonNullObject(params))\n            throw new Error(\"Got unexpected type of params. Expected object.\");\n        const { data } = await this.client.post(path, params).catch(parseAxiosError);\n        if (data === null) {\n            throw new Error(\"Received null response from server\");\n        }\n        return data;\n    }\n    // The /blocks endpoints\n    async blocksLatest() {\n        const responseData = await this.get(\"/blocks/latest\");\n        if (!responseData.block) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    async blocks(height) {\n        const responseData = await this.get(`/blocks/${height}`);\n        if (!responseData.block) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    // The /node_info endpoint\n    async nodeInfo() {\n        const responseData = await this.get(\"/node_info\");\n        if (!responseData.node_info) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    // The /txs endpoints\n    async txById(id) {\n        const responseData = await this.get(`/txs/${id}`);\n        if (!responseData.tx) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    async txsQuery(query) {\n        const responseData = await this.get(`/txs?${query}`);\n        if (!responseData.txs) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    /** returns the amino-encoding of the transaction performed by the server */\n    async encodeTx(tx) {\n        const responseData = await this.post(\"/txs/encode\", tx);\n        if (!responseData.tx) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    /**\n     * Broadcasts a signed transaction to the transaction pool.\n     * Depending on the client's broadcast mode, this might or might\n     * wait for checkTx or deliverTx to be executed before returning.\n     *\n     * @param tx a signed transaction as StdTx (i.e. not wrapped in type/value container)\n     */\n    async postTx(tx) {\n        const params = {\n            tx: tx,\n            mode: this.broadcastMode,\n        };\n        const responseData = await this.post(\"/txs\", params);\n        if (!responseData.txhash) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n}\nexports.LcdClient = LcdClient;\n//# sourceMappingURL=lcdclient.js.map"]},"metadata":{},"sourceType":"script"}