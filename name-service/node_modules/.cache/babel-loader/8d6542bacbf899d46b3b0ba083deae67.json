{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = exports.makeCosmoshubPath = exports.prehash = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nfunction prehash(bytes, type) {\n  switch (type) {\n    case null:\n      return new Uint8Array([...bytes]);\n\n    case \"sha256\":\n      return new crypto_1.Sha256(bytes).digest();\n\n    case \"sha512\":\n      return new crypto_1.Sha512(bytes).digest();\n\n    default:\n      throw new Error(\"Unknown prehash type\");\n  }\n}\n\nexports.prehash = prehash;\n/**\n * The Cosmoshub derivation path in the form `m/44'/118'/0'/0/a`\n * with 0-based account index `a`.\n */\n\nfunction makeCosmoshubPath(a) {\n  return [crypto_1.Slip10RawIndex.hardened(44), crypto_1.Slip10RawIndex.hardened(118), crypto_1.Slip10RawIndex.hardened(0), crypto_1.Slip10RawIndex.normal(0), crypto_1.Slip10RawIndex.normal(a)];\n}\n\nexports.makeCosmoshubPath = makeCosmoshubPath;\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\n\nexports.cosmjsSalt = encoding_1.toAscii(\"The CosmJS salt.\");\n\nasync function executeKdf(password, configuration) {\n  switch (configuration.algorithm) {\n    case \"argon2id\":\n      {\n        const options = configuration.params;\n        if (!crypto_1.isArgon2idOptions(options)) throw new Error(\"Invalid format of argon2id params\");\n        return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);\n      }\n\n    default:\n      throw new Error(\"Unsupported KDF algorithm\");\n  }\n}\n\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n  xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\"\n};\n\nasync function encrypt(plaintext, encryptionKey, config) {\n  switch (config.algorithm) {\n    case exports.supportedAlgorithms.xchacha20poly1305Ietf:\n      {\n        const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength); // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n\n        return new Uint8Array([...nonce, ...(await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce))]);\n      }\n\n    default:\n      throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n  }\n}\n\nexports.encrypt = encrypt;\n\nasync function decrypt(ciphertext, encryptionKey, config) {\n  switch (config.algorithm) {\n    case exports.supportedAlgorithms.xchacha20poly1305Ietf:\n      {\n        const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n        return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);\n      }\n\n    default:\n      throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n  }\n}\n\nexports.decrypt = decrypt;","map":{"version":3,"sources":["../src/wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = exports.makeCosmoshubPath = exports.prehash = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nfunction prehash(bytes, type) {\n    switch (type) {\n        case null:\n            return new Uint8Array([...bytes]);\n        case \"sha256\":\n            return new crypto_1.Sha256(bytes).digest();\n        case \"sha512\":\n            return new crypto_1.Sha512(bytes).digest();\n        default:\n            throw new Error(\"Unknown prehash type\");\n    }\n}\nexports.prehash = prehash;\n/**\n * The Cosmoshub derivation path in the form `m/44'/118'/0'/0/a`\n * with 0-based account index `a`.\n */\nfunction makeCosmoshubPath(a) {\n    return [\n        crypto_1.Slip10RawIndex.hardened(44),\n        crypto_1.Slip10RawIndex.hardened(118),\n        crypto_1.Slip10RawIndex.hardened(0),\n        crypto_1.Slip10RawIndex.normal(0),\n        crypto_1.Slip10RawIndex.normal(a),\n    ];\n}\nexports.makeCosmoshubPath = makeCosmoshubPath;\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\nexports.cosmjsSalt = encoding_1.toAscii(\"The CosmJS salt.\");\nasync function executeKdf(password, configuration) {\n    switch (configuration.algorithm) {\n        case \"argon2id\": {\n            const options = configuration.params;\n            if (!crypto_1.isArgon2idOptions(options))\n                throw new Error(\"Invalid format of argon2id params\");\n            return crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);\n        }\n        default:\n            throw new Error(\"Unsupported KDF algorithm\");\n    }\n}\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n    xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\",\n};\nasync function encrypt(plaintext, encryptionKey, config) {\n    switch (config.algorithm) {\n        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {\n            const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);\n            // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n            return new Uint8Array([\n                ...nonce,\n                ...(await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)),\n            ]);\n        }\n        default:\n            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n    }\n}\nexports.encrypt = encrypt;\nasync function decrypt(ciphertext, encryptionKey, config) {\n    switch (config.algorithm) {\n        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {\n            const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n            return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);\n        }\n        default:\n            throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);\n    }\n}\nexports.decrypt = decrypt;\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"script"}